{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/maupassant/source/css/jquery.fancybox.css","path":"css/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1477991540999},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1477991540999},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1477991540999},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1477991540999},{"_id":"themes/landscape/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1477991540999},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1477991540999},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1477991467784},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1477991540999},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1477991540999},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1477991540999},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1477991540999},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1477991540999},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1477991540999},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1477991540999},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1477991540999},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1477991540999},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1477991540999},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1477991540999},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1477991540999},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1477991540999},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1477991540999},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1477991540999},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1477991540999},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1477991540999},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1477991540999},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1477991540999},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1477991540999},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1477991540999},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1477991540999},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1477991540999},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1477991540999},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1477991540999},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1477991540999},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1477991540999},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1477991540999},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1477991540999},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1477991540999},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1477991540999},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1477991540999},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1477991541003},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1477991541003},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1477991541003},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1477991541003},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1477991541003},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1477991541003},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1477991541003},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1477991541003},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1477991541007},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1477991541007},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1477991541007},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1477991540999},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1477991540999},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1477991540999},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1477991540999},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1477991540999},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1477991540999},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1477991540999},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1477991540999},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1477991540999},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1477991540999},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1477991540999},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1477991540999},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1477991540999},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1477991540999},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1477991540999},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1477991540999},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1477991540999},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1477991541003},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1477991541003},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1477991541003},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1477991541003},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1477991541003},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1477991541003},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1477991541003},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1477991540999},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1477991540999},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1477991540999},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1477991541003},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1477991541003},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1477991541003},{"_id":"public/2016/11/01/hello-world/index.html","hash":"d574d51d523c2c8b6676c3dabc641d6590d2ae2d","modified":1477993572689},{"_id":"public/archives/index.html","hash":"87056479f61e5b9dacf250c95bde1c786db423e8","modified":1478065012563},{"_id":"public/archives/2016/index.html","hash":"87056479f61e5b9dacf250c95bde1c786db423e8","modified":1478065012563},{"_id":"public/archives/2016/11/index.html","hash":"b14cabfe12ee034b97505e2d5a91612e34956870","modified":1477993793648},{"_id":"public/index.html","hash":"47031cc76a7d8aca6ef29e2bbbfb1d9eeb8a4d47","modified":1478065012563},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1477991610465},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1477991610465},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1477991610465},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1477991610465},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1477991610465},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1477991610465},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1477991610465},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1477991610465},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1477991610466},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1477991610466},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1477991611142},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1477991611148},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1477991611148},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1477991611148},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1477991611148},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1477991611149},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1477991611149},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1477991611149},{"_id":"public/css/style.css","hash":"2afb6e7e24abf81c8b7b7d472fb0bb9b9a1eac16","modified":1477992011985},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1477991611149},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1477991611149},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1477991611153},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1477991611155},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1477991817965},{"_id":"themes/maupassant/LICENSE","hash":"019dc6a9aba02ae3aaabca45f39aecd6e8e7f1d8","modified":1477991817965},{"_id":"themes/maupassant/README.md","hash":"75d8c42569809961953d1934de445418c00ab94c","modified":1477991817965},{"_id":"themes/maupassant/_config.yml","hash":"8c21341a2876c2a1c9807be5e2c724a4e39166e3","modified":1477991817965},{"_id":"themes/maupassant/package.json","hash":"81fb4e2ac051ecfb9a93f37b28910291b939771a","modified":1477991817965},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1477991817949},{"_id":"themes/maupassant/.git/config","hash":"776ed8041073d1bb2a234fa37a0d49bad1f0c5f4","modified":1477991817949},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1477991813557},{"_id":"themes/maupassant/.git/index","hash":"75f372103093473e7647124a7638664211e2c3f1","modified":1477991817965},{"_id":"themes/maupassant/.git/packed-refs","hash":"53e4275068b4dbaa003c4f6e8f4eeaa4ed2360d0","modified":1477991817949},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1477991817965},{"_id":"themes/maupassant/languages/en.yml","hash":"e13ab1a2d2f1edbe67b4c035fd4667cb6a31db8e","modified":1477991817965},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1477991817965},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1477991817965},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1477991817965},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"ebacfa5d0c14d603e0d505757adb24c0bbe5dd13","modified":1477991817965},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"56b65995c60e99dcebbf00168447fd225d28e5b2","modified":1477991817965},{"_id":"themes/maupassant/layout/archive.jade","hash":"0050c883b4f202add71c8664d65e6072179e7190","modified":1477991817965},{"_id":"themes/maupassant/layout/base-without-sidebar.jade","hash":"1ad721de96784bf4253316b796db6200148d4152","modified":1477991817965},{"_id":"themes/maupassant/layout/base.jade","hash":"852c610ac392ef2fa130dbe73bcf4f96f423c869","modified":1477991817965},{"_id":"themes/maupassant/layout/index.jade","hash":"7466ce52023ed8a413a6b4461354a9e20e62fc14","modified":1477991817965},{"_id":"themes/maupassant/layout/page.jade","hash":"8d70fd3b93f2c9087a9ea7ec538dcc1d413bea01","modified":1477991817965},{"_id":"themes/maupassant/layout/post.jade","hash":"9cf29fb0daed95935154ce0fa2b154df5a9b11b1","modified":1477991817965},{"_id":"themes/maupassant/layout/single-column.jade","hash":"c35fff4d9b331a41af5bc10f4278ec3d9da503db","modified":1477991817965},{"_id":"themes/maupassant/layout/timeline.jade","hash":"f03d8df63a188543cfe4e85e76194abe081411a1","modified":1477991817965},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1477991813557},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1477991813557},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1477991813557},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1477991813557},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1477991813557},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1477991813557},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1477991813557},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1477991813557},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1477991813557},{"_id":"themes/maupassant/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1477991813557},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"4d42196af8e96ae229cf151fdd4406a996828562","modified":1477991817949},{"_id":"themes/maupassant/layout/_partial/after_footer.jade","hash":"3dbcc9a9f0d6e55da191d3393c18bbfcfe99fa69","modified":1477991817965},{"_id":"themes/maupassant/layout/_partial/comments.jade","hash":"6c7f63ba04a4d28323ba31e79a4927f3d3fcc56e","modified":1477991817965},{"_id":"themes/maupassant/layout/_partial/footer.jade","hash":"aa020b794e697e8e9612530c97c6295efde469fe","modified":1477991817965},{"_id":"themes/maupassant/layout/_partial/helpers.jade","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1477991817965},{"_id":"themes/maupassant/layout/_partial/mathjax.jade","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1477991817965},{"_id":"themes/maupassant/layout/_partial/mathjax2.jade","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1477991817965},{"_id":"themes/maupassant/layout/_partial/paginator.jade","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1477991817965},{"_id":"themes/maupassant/layout/_partial/post_nav.jade","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1477991817965},{"_id":"themes/maupassant/layout/_partial/tag.jade","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1477991817965},{"_id":"themes/maupassant/layout/_partial/totop.jade","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1477991817965},{"_id":"themes/maupassant/layout/_widget/category.jade","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1477991817965},{"_id":"themes/maupassant/layout/_widget/links.jade","hash":"f57a0c76d243882b2b77330132bdb43bc648948b","modified":1477991817965},{"_id":"themes/maupassant/layout/_widget/recent_comments.jade","hash":"e119c5afa85abc60d139e2da99b0bfcd7a6530f8","modified":1477991817965},{"_id":"themes/maupassant/layout/_widget/recent_posts.jade","hash":"19431336d724d2118e46da43683bce9063176541","modified":1477991817965},{"_id":"themes/maupassant/layout/_widget/search.jade","hash":"658e92c054eecf15cbe61576f5c6985789d8d430","modified":1477993561626},{"_id":"themes/maupassant/layout/_widget/tag.jade","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1477991817965},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1477991817965},{"_id":"themes/maupassant/source/css/style.scss","hash":"158f1ebecf7b994ffae5332a627465f6bf38113b","modified":1477991817965},{"_id":"themes/maupassant/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1477991817965},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1477991817965},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1477991817965},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1477991817965},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1477991817965},{"_id":"themes/maupassant/source/js/search.js","hash":"53db2eb255dd40a412ed62ea7332ca5a22f7816f","modified":1477991817965},{"_id":"themes/maupassant/source/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1477991817965},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1477991817965},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1477991817965},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1477991817965},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1477991817965},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1477991817965},{"_id":"themes/maupassant/.git/objects/pack/pack-f2f400e4bfbf1eeb085cd61f1cda22db92b7c5b7.idx","hash":"9b0feb7182dfb24f8e48aba6c5ecba3f1db2ee2f","modified":1477991817861},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"9138f76c9461186fe7e14add27270f388fdabe2f","modified":1477991817949},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"4d42196af8e96ae229cf151fdd4406a996828562","modified":1477991817949},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1477991817949},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"4d42196af8e96ae229cf151fdd4406a996828562","modified":1477991817949},{"_id":"themes/maupassant/.git/objects/pack/pack-f2f400e4bfbf1eeb085cd61f1cda22db92b7c5b7.pack","hash":"5bd7aae20c2f1332ca48c37f88a4a968c86c480a","modified":1477991817861},{"_id":"public/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1477992011984},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1477992011984},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1477992011985},{"_id":"public/js/search.js","hash":"53db2eb255dd40a412ed62ea7332ca5a22f7816f","modified":1477992011985},{"_id":"public/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1477992011985},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1477992011985},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1477992011985},{"_id":"source/_posts/gitignore.md","hash":"9d4bfd2d932e1ef5b00b95f2fc6a3e0b2da0252a","modified":1478053341925},{"_id":"source/_posts/host.md","hash":"6c72ecd242dfb8acbce8e595acaff420f54b7a0e","modified":1478053336097},{"_id":"source/_posts/闭包.md","hash":"2da713a63bad4b56a835edde3339c8aa2b9d3c48","modified":1478053369493},{"_id":"public/2016/11/01/gitignore/index.html","hash":"4082eb9447420e137394e5cf6d187cf22c1135e5","modified":1477993793646},{"_id":"public/2016/11/01/host/index.html","hash":"9136b74f63e115596d9b9e359f4c3ce124c00160","modified":1477993793647},{"_id":"public/tags/git/index.html","hash":"b291b79bcaf27971eacaccfaa9c25db72a6bd88b","modified":1478065012563},{"_id":"public/tags/其他/index.html","hash":"174c9347c70c9b6d6c659d7ff8728957463bb96a","modified":1478065012563},{"_id":"public/tags/javascript/index.html","hash":"dac82d5ea592af1f43d0b63699a586b1b6341556","modified":1478065012563},{"_id":"public/2016/11/01/闭包/index.html","hash":"4a817aaacaab6e7fe36406724ccd345730a3f3c4","modified":1477993793648},{"_id":"source/_posts/into-project-shell.md","hash":"9251bb02cb7ea7b2150d6af5a6bb633f0c486c7e","modified":1478053340285},{"_id":"public/2016/11/01/into-project-shell/index.html","hash":"f2c501e0cd08e7c27ce8829f21441011c508ef2d","modified":1477993793658},{"_id":"public/tags/shell/index.html","hash":"375750e43534477451d1e36304d1e03e5e191ec4","modified":1478065012563},{"_id":"source/gf.ico","hash":"9b4300139f9055d2620e16fa23599985ad3ada82","modified":1478063406415},{"_id":"source/favicon.ico","hash":"7bcbc969d386e3ec28a1eecb0e687da68bbe04c3","modified":1478063756378},{"_id":"themes/maupassant/source/css/images/favicon.ico","hash":"7bcbc969d386e3ec28a1eecb0e687da68bbe04c3","modified":1478063756378},{"_id":"public/2016/10/13/host/index.html","hash":"4d885e37b912dccf834f9d755ee999d3f60cb351","modified":1478065012562},{"_id":"public/2016/09/04/gitignore/index.html","hash":"504029bdc482d9197480c42c7f9caf21524b4bc8","modified":1478065012562},{"_id":"public/2016/07/13/into-project-shell/index.html","hash":"4275b9c1dae66a0977dceda8dd734e55a63193c0","modified":1478065012562},{"_id":"public/archives/2016/07/index.html","hash":"3bbc99ceb57ebede946789018c55628d7e2e54df","modified":1478065012563},{"_id":"public/archives/2016/08/index.html","hash":"c486f8fe0b7f0dbf53632e2dcdfa287487ac9f0a","modified":1478065012563},{"_id":"public/archives/2016/09/index.html","hash":"f6121a59c4276728d6c32d6f44e20ffe3a4aadab","modified":1478065012563},{"_id":"public/archives/2016/10/index.html","hash":"f64562b1da77c45b6ea79a70d1819df4f6914972","modified":1478065012563},{"_id":"public/2016/08/26/闭包/index.html","hash":"1543ca7c4648ae58a6e441b07acb1b8d29d1b6b3","modified":1478065012563},{"_id":"source/_about/index.md","hash":"1041179cbdda366fd7b0347f09255f775170e103","modified":1478065071531},{"_id":"source/about/index.md","hash":"ab1d7ac3823f0b3a7f0c39685a5a5d5dc3823981","modified":1478065207487},{"_id":"public/about/index.html","hash":"9e54e98ac9f4c0c2c3fc10f56d57a55a90e37569","modified":1478065212526}],"Category":[],"Data":[],"Page":[{"_content":"这里将会是个人简介","source":"about/index.md","raw":"这里将会是个人简介","date":"2016-11-02T05:40:07.487Z","updated":"2016-11-02T05:40:07.487Z","path":"about/index.html","_id":"civ0htmiu0000fv7tpldsay6f","title":"","comments":1,"layout":"page","content":"<p>这里将会是个人简介</p>\n","excerpt":"","more":"<p>这里将会是个人简介</p>\n"}],"Post":[{"title":"git忽略","date":"2016-09-03T16:00:00.000Z","_content":"### .gitignore\n 1.在项目的根目录下打开.gitignore文件（如果没有则新建），添加你要忽略的文件或者文件夹，例如： *.json,theme/\n 2.清除缓存\n{% codeblock  %}\n\tgit rm -rf --cached .\n\tgit add .\n{% endcodeblock %}\n\n3.这时修改的.gitignore就生效了。","source":"_posts/gitignore.md","raw":"---\ntitle: git忽略\ntags: git\ndate: 2016/9/04 \n---\n### .gitignore\n 1.在项目的根目录下打开.gitignore文件（如果没有则新建），添加你要忽略的文件或者文件夹，例如： *.json,theme/\n 2.清除缓存\n{% codeblock  %}\n\tgit rm -rf --cached .\n\tgit add .\n{% endcodeblock %}\n\n3.这时修改的.gitignore就生效了。","slug":"gitignore","published":1,"updated":"2016-11-02T02:22:21.925Z","_id":"ciuzabcba0000fv7tu85213fi","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"gitignore\"><a href=\"#gitignore\" class=\"headerlink\" title=\".gitignore\"></a>.gitignore</h3><p> 1.在项目的根目录下打开.gitignore文件（如果没有则新建），添加你要忽略的文件或者文件夹，例如： *.json,theme/<br> 2.清除缓存<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git rm -rf --cached .</div><div class=\"line\">git add .</div></pre></td></tr></table></figure></p>\n<p>3.这时修改的.gitignore就生效了。</p>\n","excerpt":"","more":"<h3 id=\"gitignore\"><a href=\"#gitignore\" class=\"headerlink\" title=\".gitignore\"></a>.gitignore</h3><p> 1.在项目的根目录下打开.gitignore文件（如果没有则新建），添加你要忽略的文件或者文件夹，例如： *.json,theme/<br> 2.清除缓存<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git rm -rf --cached .</div><div class=\"line\">git add .</div></pre></td></tr></table></figure></p>\n<p>3.这时修改的.gitignore就生效了。</p>\n"},{"title":"Chrome浏览器host配置","date":"2016-10-12T16:00:00.000Z","_content":"### Chrome浏览器host配置\n#### 一、host文件配置\n##### Windows平台\n1.使用文本编辑器打开： %SystemRoot%\\System32\\drivers\\etc\\hosts\n2.将 [hosts](https://raw.githubusercontent.com/racaljk/hosts/master/hosts) 全部内容复制到上面的文件内并保存\n##### Linux系统\n1.将 hosts 全部内容复制到/etc/hosts中并保存\n2.或者在终端执行：\n{% codeblock  %}\nwget https://raw.githubusercontent.com/racaljk/hosts/master/hosts -qO /tmp/hosts && sudo sh -c 'cat /tmp/hosts > /etc/hosts' \n{% endcodeblock %}\n#### 二、Chrome配置\n1.地址栏输入：`chrome://net-internals/#hsts`,回车\n2.` Input a domain name to add it to the HSTS set: `这一行下面的`` Domain: [ ]``输入`` www.google.com.hk ``点 **Add**按钮\n\n#### 三、重启浏览器\n\n[原文](https://github.com/racaljk/hosts)及相关问题 请访问`https://github.com/racaljk/hosts`","source":"_posts/host.md","raw":"---\ntitle: Chrome浏览器host配置\ntags : 其他\ndate: 2016/10/13 \n---\n### Chrome浏览器host配置\n#### 一、host文件配置\n##### Windows平台\n1.使用文本编辑器打开： %SystemRoot%\\System32\\drivers\\etc\\hosts\n2.将 [hosts](https://raw.githubusercontent.com/racaljk/hosts/master/hosts) 全部内容复制到上面的文件内并保存\n##### Linux系统\n1.将 hosts 全部内容复制到/etc/hosts中并保存\n2.或者在终端执行：\n{% codeblock  %}\nwget https://raw.githubusercontent.com/racaljk/hosts/master/hosts -qO /tmp/hosts && sudo sh -c 'cat /tmp/hosts > /etc/hosts' \n{% endcodeblock %}\n#### 二、Chrome配置\n1.地址栏输入：`chrome://net-internals/#hsts`,回车\n2.` Input a domain name to add it to the HSTS set: `这一行下面的`` Domain: [ ]``输入`` www.google.com.hk ``点 **Add**按钮\n\n#### 三、重启浏览器\n\n[原文](https://github.com/racaljk/hosts)及相关问题 请访问`https://github.com/racaljk/hosts`","slug":"host","published":1,"updated":"2016-11-02T02:22:16.097Z","_id":"ciuzabcbl0004fv7tl139l4wr","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"Chrome浏览器host配置\"><a href=\"#Chrome浏览器host配置\" class=\"headerlink\" title=\"Chrome浏览器host配置\"></a>Chrome浏览器host配置</h3><h4 id=\"一、host文件配置\"><a href=\"#一、host文件配置\" class=\"headerlink\" title=\"一、host文件配置\"></a>一、host文件配置</h4><h5 id=\"Windows平台\"><a href=\"#Windows平台\" class=\"headerlink\" title=\"Windows平台\"></a>Windows平台</h5><p>1.使用文本编辑器打开： %SystemRoot%\\System32\\drivers\\etc\\hosts<br>2.将 <a href=\"https://raw.githubusercontent.com/racaljk/hosts/master/hosts\" target=\"_blank\" rel=\"external\">hosts</a> 全部内容复制到上面的文件内并保存</p>\n<h5 id=\"Linux系统\"><a href=\"#Linux系统\" class=\"headerlink\" title=\"Linux系统\"></a>Linux系统</h5><p>1.将 hosts 全部内容复制到/etc/hosts中并保存<br>2.或者在终端执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget https://raw.githubusercontent.com/racaljk/hosts/master/hosts -qO /tmp/hosts &amp;&amp; sudo sh -c &apos;cat /tmp/hosts &gt; /etc/hosts&apos; </div></pre></td></tr></table></figure></p>\n<h4 id=\"二、Chrome配置\"><a href=\"#二、Chrome配置\" class=\"headerlink\" title=\"二、Chrome配置\"></a>二、Chrome配置</h4><p>1.地址栏输入：<code>chrome://net-internals/#hsts</code>,回车<br>2.<code>Input a domain name to add it to the HSTS set:</code>这一行下面的<code>Domain: [ ]</code>输入<code>www.google.com.hk</code>点 <strong>Add</strong>按钮</p>\n<h4 id=\"三、重启浏览器\"><a href=\"#三、重启浏览器\" class=\"headerlink\" title=\"三、重启浏览器\"></a>三、重启浏览器</h4><p><a href=\"https://github.com/racaljk/hosts\" target=\"_blank\" rel=\"external\">原文</a>及相关问题 请访问<code>https://github.com/racaljk/hosts</code></p>\n","excerpt":"","more":"<h3 id=\"Chrome浏览器host配置\"><a href=\"#Chrome浏览器host配置\" class=\"headerlink\" title=\"Chrome浏览器host配置\"></a>Chrome浏览器host配置</h3><h4 id=\"一、host文件配置\"><a href=\"#一、host文件配置\" class=\"headerlink\" title=\"一、host文件配置\"></a>一、host文件配置</h4><h5 id=\"Windows平台\"><a href=\"#Windows平台\" class=\"headerlink\" title=\"Windows平台\"></a>Windows平台</h5><p>1.使用文本编辑器打开： %SystemRoot%\\System32\\drivers\\etc\\hosts<br>2.将 <a href=\"https://raw.githubusercontent.com/racaljk/hosts/master/hosts\">hosts</a> 全部内容复制到上面的文件内并保存</p>\n<h5 id=\"Linux系统\"><a href=\"#Linux系统\" class=\"headerlink\" title=\"Linux系统\"></a>Linux系统</h5><p>1.将 hosts 全部内容复制到/etc/hosts中并保存<br>2.或者在终端执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget https://raw.githubusercontent.com/racaljk/hosts/master/hosts -qO /tmp/hosts &amp;&amp; sudo sh -c &apos;cat /tmp/hosts &gt; /etc/hosts&apos; </div></pre></td></tr></table></figure></p>\n<h4 id=\"二、Chrome配置\"><a href=\"#二、Chrome配置\" class=\"headerlink\" title=\"二、Chrome配置\"></a>二、Chrome配置</h4><p>1.地址栏输入：<code>chrome://net-internals/#hsts</code>,回车<br>2.<code>Input a domain name to add it to the HSTS set:</code>这一行下面的<code>Domain: [ ]</code>输入<code>www.google.com.hk</code>点 <strong>Add</strong>按钮</p>\n<h4 id=\"三、重启浏览器\"><a href=\"#三、重启浏览器\" class=\"headerlink\" title=\"三、重启浏览器\"></a>三、重启浏览器</h4><p><a href=\"https://github.com/racaljk/hosts\">原文</a>及相关问题 请访问<code>https://github.com/racaljk/hosts</code></p>\n"},{"title":"Javascript闭包","date":"2016-08-25T16:00:00.000Z","_content":"### Javascript闭包\n闭包是指能够访问自由变量的函数 (变量在本地使用，但在闭包中定义)。换句话说，定义在闭包中的函数可以“记忆”它被创建时候的环境。\n\n**先看下面这个函数**\n\n{% codeblock lang:javascript %}\nfunction foo() {\n  var city = \"西安\";\n  function getCity() {\n    console.log(city);\n  }\n  getCity();\n}\nfoo();//控制台输出'西安'\n{% endcodeblock %}\n\n\n函数 foo() 创建了一个局部变量 city，然后定义了名为 getCity() 的函数。 getCity() 是一个内部函数——定义于 foo() 之内且仅在该函数体内可用。getCity() 没有任何自己的局部变量，然而它可以访问到外部函数的变量，即可以使用父函数中声明的 city 变量。\n\n#### 一、闭包\n**再看这样一个函数**\n{% codeblock lang:javascript %}\n\tfunction foo1() {\n\t  var city = \"西安\";\n\t  function getCity() {\n\t    console.log(city);\n\t  }\n\t  return getCity;\n\t}\n\t\n\tvar foo2 = foo1();\n\tfoo2();//控制台输出西安\n{% endcodeblock %}\n\n\n 运行这段代码的效果和之前的 foo() 示例完全一样：字符串 \"西安\" 将被显示在一个 控制台中。其中的不同也是有意思的地方在于 getCity()内部函数在执行前被从其外围函数foo1中返回了。\n\n这段代码看起来别扭却能正常运行。通常，函数中的局部变量仅在函数的执行期间可用。一旦foo1()执行过后，我们会很合理的认为 city变量将不再可用。虽然代码运行的没问题，但实际并不是这样的。\n\n这个谜题的答案是foo1变成一个闭包了。闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，foo1是一个闭包，由getCity函数和闭包创建时存在的\"西安\"字符串形成。\n\n下面是一个更有意思的示例 — makeAdder 函数：\n\n{% codeblock lang:javascript %}\n\nfunction makeAdder(x) {\n  return function(y) {\n    return x + y;\n  };\n}\n\nvar add5 = makeAdder(5);\nvar add10 = makeAdder(10);\n\nconsole.log(add5(2));  // 7\nconsole.log(add10(2)); // 12\n{% endcodeblock %}\n在这个示例中，我们定义了 makeAdder(x) 函数：带有一个参数 x 并返回一个新的函数。返回的函数带有一个参数 y，并返回 x 和 y 的和。\n\n从本质上讲，makeAdder 是一个函数工厂 — 创建将指定的值和它的参数求和的函数，在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。\n\nadd5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。\n\n实用的闭包\n理论就是这些了 — 可是闭包确实有用吗？让我们看看闭包的实践意义。闭包允许将函数与其所操作的某些数据（环境）关连起来。这显然类似于面向对象编程。在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。\n\n因而，一般说来，可以使用只有一个方法的对象的地方，都可以使用闭包。\n\n在 Web 中，您可能想这样做的情形非常普遍。大部分我们所写的 Web JavaScript 代码都是事件驱动的 — 定义某种行为，然后将其添加到用户触发的事件之上（比如点击或者按键）。我们的代码通常添加为回调：响应事件而执行的函数。\n\n以下是一个实际的示例：假设我们想在页面上添加一些可以调整字号的按钮。一种方法是以像素为单位指定 body 元素的 font-size，然后通过相对的 em 单位设置页面中其它元素（例如页眉）的字号：\n\nbody {\n  font-family: Helvetica, Arial, sans-serif;\n  font-size: 12px;\n}\n\nh1 {\n  font-size: 1.5em;\n}\nh2 {\n  font-size: 1.2em;\n}\n我们的交互式的文本尺寸按钮可以修改 body 元素的 font-size 属性，而由于我们使用相对的单位，页面中的其它元素也会相应地调整。\n\n以下是 JavaScript：\n\nfunction makeSizer(size) {\n  return function() {\n    document.body.style.fontSize = size + 'px';\n  };\n}\n\nvar size12 = makeSizer(12);\nvar size14 = makeSizer(14);\nvar size16 = makeSizer(16);\nsize12，size14 和 size16 为将 body 文本相应地调整为 12，14，16 像素的函数。我们可以将它们分别添加到按钮上（这里是链接）。如下所示：\n\ndocument.getElementById('size-12').onclick = size12;\ndocument.getElementById('size-14').onclick = size14;\ndocument.getElementById('size-16').onclick = size16;\n<a href=\"#\" id=\"size-12\">12</a>\n<a href=\"#\" id=\"size-14\">14</a>\n<a href=\"#\" id=\"size-16\">16</a>\n\n\n \n\n用闭包模拟私有方法\n诸如 Java 在内的一些语言支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。\n\n对此，JavaScript 并不提供原生的支持，但是可以使用闭包模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。\n\n下面的示例展现了如何使用闭包来定义公共函数，且其可以访问私有函数和变量。这个方式也称为 模块模式（module pattern）：\n\nvar Counter = (function() {\n  var privateCounter = 0;\n  function changeBy(val) {\n    privateCounter += val;\n  }\n  return {\n    increment: function() {\n      changeBy(1);\n    },\n    decrement: function() {\n      changeBy(-1);\n    },\n    value: function() {\n      return privateCounter;\n    }\n  }   \n})();\n\nconsole.log(Counter.value()); /* logs 0 */\nCounter.increment();\nCounter.increment();\nconsole.log(Counter.value()); /* logs 2 */\nCounter.decrement();\nconsole.log(Counter.value()); /* logs 1 */\n这里有很多细节。在以往的示例中，每个闭包都有它自己的环境；而这次我们只创建了一个环境，为三个函数所共享：Counter.increment，Counter.decrement 和 Counter.value。\n\n该共享环境创建于一个匿名函数体内，该函数一经定义立刻执行。环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。 这两项都无法在匿名函数外部直接访问。必须通过匿名包装器返回的三个公共函数访问。\n\n这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法范围的作用域，它们都可以访问 privateCounter 变量和 changeBy 函数。\n\n您应该注意到了，我们定义了一个匿名函数用于创建计数器，然后直接调用该函数，并将返回值赋给 Counter 变量。也可以将这个函数保存到另一个变量中，以便创建多个计数器。\n\nvar makeCounter = function() {\n  var privateCounter = 0;\n  function changeBy(val) {\n    privateCounter += val;\n  }\n  return {\n    increment: function() {\n      changeBy(1);\n    },\n    decrement: function() {\n      changeBy(-1);\n    },\n    value: function() {\n      return privateCounter;\n    }\n  }  \n};\n\nvar Counter1 = makeCounter();\nvar Counter2 = makeCounter();\nconsole.log(Counter1.value()); /* logs 0 */\nCounter1.increment();\nCounter1.increment();\nconsole.log(Counter1.value()); /* logs 2 */\nCounter1.decrement();\nconsole.log(Counter1.value()); /* logs 1 */\nconsole.log(Counter2.value()); /* logs 0 */\n请注意两个计数器是如何维护它们各自的独立性的。每次调用 makeCounter() 函数期间，其环境是不同的。每次调用中， privateCounter 中含有不同的实例。\n\n这种形式的闭包提供了许多通常由面向对象编程U所享有的益处，尤其是数据隐藏和封装。\n\n在循环中创建闭包：一个常见错误\n在 JavaScript 1.7 引入 let 关键字 之前，闭包的一个常见的问题发生于在循环中创建闭包。参考下面的示例：\n\n<p id=\"help\">Helpful notes will appear here</p>\n<p>E-mail: <input type=\"text\" id=\"email\" name=\"email\"></p>\n<p>Name: <input type=\"text\" id=\"name\" name=\"name\"></p>\n<p>Age: <input type=\"text\" id=\"age\" name=\"age\"></p>\nfunction showHelp(help) {\n  document.getElementById('help').innerHTML = help;\n}\n\nfunction setupHelp() {\n  var helpText = [\n      {'id': 'email', 'help': 'Your e-mail address'},\n      {'id': 'name', 'help': 'Your full name'},\n      {'id': 'age', 'help': 'Your age (you must be over 16)'}\n    ];\n\n  for (var i = 0; i < helpText.length; i++) {\n    var item = helpText[i];\n    document.getElementById(item.id).onfocus = function() {\n      showHelp(item.help);\n    }\n  }\n}\n\nsetupHelp();\n\n\n数组 helpText 中定义了三个有用的提示信息，每一个都关联于对应的文档中的输入域的 ID。通过循环这三项定义，依次为每一个输入域添加了一个 onfocus 事件处理函数，以便显示帮助信息。\n\n运行这段代码后，您会发现它没有达到想要的效果。无论焦点在哪个输入域上，显示的都是关于年龄的消息。\n\n该问题的原因在于赋给 onfocus 是闭包（setupHelp）中的匿名函数而不是闭包对象；在闭包（setupHelp）中一共创建了三个匿名函数，但是它们都共享同一个环境（item）。在 onfocus 的回调被执行时，循环早已经完成，且此时 item 变量（由所有三个闭包所共享）已经指向了 helpText 列表中的最后一项。\n\n解决这个问题的一种方案是使onfocus指向一个新的闭包对象。\n\nfunction showHelp(help) {\n  document.getElementById('help').innerHTML = help;\n}\n\nfunction makeHelpCallback(help) {\n  return function() {\n    showHelp(help);\n  };\n}\n\nfunction setupHelp() {\n  var helpText = [\n      {'id': 'email', 'help': 'Your e-mail address'},\n      {'id': 'name', 'help': 'Your full name'},\n      {'id': 'age', 'help': 'Your age (you must be over 16)'}\n    ];\n\n  for (var i = 0; i < helpText.length; i++) {\n    var item = helpText[i];\n    document.getElementById(item.id).onfocus = makeHelpCallback(item.help);\n  }\n}\n\nsetupHelp();\n\n\n这段代码可以如我们所期望的那样工作。所有的回调不再共享同一个环境， makeHelpCallback 函数为每一个回调创建一个新的环境。在这些环境中，help 指向 helpText 数组中对应的字符串。\n\n性能考量\n如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。\n\n例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用，方法都会被重新赋值一次（也就是说，为每一个对象的创建）。\n\n考虑以下虽然不切实际但却说明问题的示例：\n\nfunction MyObject(name, message) {\n  this.name = name.toString();\n  this.message = message.toString();\n  this.getName = function() {\n    return this.name;\n  };\n\n  this.getMessage = function() {\n    return this.message;\n  };\n}\n上面的代码并未利用到闭包的益处，因此，应该修改为如下常规形式：\n\nfunction MyObject(name, message) {\n  this.name = name.toString();\n  this.message = message.toString();\n}\nMyObject.prototype = {\n  getName: function() {\n    return this.name;\n  },\n  getMessage: function() {\n    return this.message;\n  }\n};\n或者改成：\n\nfunction MyObject(name, message) {\n  this.name = name.toString();\n  this.message = message.toString();\n}\nMyObject.prototype.getName = function() {\n  return this.name;\n};\nMyObject.prototype.getMessage = function() {\n  return this.message;\n};\n在前面的两个示例中，继承的原型可以为所有对象共享，且不必在每一次创建对象时定义方法。参见 对象模型的细节 一章可以了解更为详细的信息。","source":"_posts/闭包.md","raw":"---\ntitle: Javascript闭包\ntags: javascript\ndate: 2016/8/26 \n---\n### Javascript闭包\n闭包是指能够访问自由变量的函数 (变量在本地使用，但在闭包中定义)。换句话说，定义在闭包中的函数可以“记忆”它被创建时候的环境。\n\n**先看下面这个函数**\n\n{% codeblock lang:javascript %}\nfunction foo() {\n  var city = \"西安\";\n  function getCity() {\n    console.log(city);\n  }\n  getCity();\n}\nfoo();//控制台输出'西安'\n{% endcodeblock %}\n\n\n函数 foo() 创建了一个局部变量 city，然后定义了名为 getCity() 的函数。 getCity() 是一个内部函数——定义于 foo() 之内且仅在该函数体内可用。getCity() 没有任何自己的局部变量，然而它可以访问到外部函数的变量，即可以使用父函数中声明的 city 变量。\n\n#### 一、闭包\n**再看这样一个函数**\n{% codeblock lang:javascript %}\n\tfunction foo1() {\n\t  var city = \"西安\";\n\t  function getCity() {\n\t    console.log(city);\n\t  }\n\t  return getCity;\n\t}\n\t\n\tvar foo2 = foo1();\n\tfoo2();//控制台输出西安\n{% endcodeblock %}\n\n\n 运行这段代码的效果和之前的 foo() 示例完全一样：字符串 \"西安\" 将被显示在一个 控制台中。其中的不同也是有意思的地方在于 getCity()内部函数在执行前被从其外围函数foo1中返回了。\n\n这段代码看起来别扭却能正常运行。通常，函数中的局部变量仅在函数的执行期间可用。一旦foo1()执行过后，我们会很合理的认为 city变量将不再可用。虽然代码运行的没问题，但实际并不是这样的。\n\n这个谜题的答案是foo1变成一个闭包了。闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，foo1是一个闭包，由getCity函数和闭包创建时存在的\"西安\"字符串形成。\n\n下面是一个更有意思的示例 — makeAdder 函数：\n\n{% codeblock lang:javascript %}\n\nfunction makeAdder(x) {\n  return function(y) {\n    return x + y;\n  };\n}\n\nvar add5 = makeAdder(5);\nvar add10 = makeAdder(10);\n\nconsole.log(add5(2));  // 7\nconsole.log(add10(2)); // 12\n{% endcodeblock %}\n在这个示例中，我们定义了 makeAdder(x) 函数：带有一个参数 x 并返回一个新的函数。返回的函数带有一个参数 y，并返回 x 和 y 的和。\n\n从本质上讲，makeAdder 是一个函数工厂 — 创建将指定的值和它的参数求和的函数，在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。\n\nadd5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。\n\n实用的闭包\n理论就是这些了 — 可是闭包确实有用吗？让我们看看闭包的实践意义。闭包允许将函数与其所操作的某些数据（环境）关连起来。这显然类似于面向对象编程。在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。\n\n因而，一般说来，可以使用只有一个方法的对象的地方，都可以使用闭包。\n\n在 Web 中，您可能想这样做的情形非常普遍。大部分我们所写的 Web JavaScript 代码都是事件驱动的 — 定义某种行为，然后将其添加到用户触发的事件之上（比如点击或者按键）。我们的代码通常添加为回调：响应事件而执行的函数。\n\n以下是一个实际的示例：假设我们想在页面上添加一些可以调整字号的按钮。一种方法是以像素为单位指定 body 元素的 font-size，然后通过相对的 em 单位设置页面中其它元素（例如页眉）的字号：\n\nbody {\n  font-family: Helvetica, Arial, sans-serif;\n  font-size: 12px;\n}\n\nh1 {\n  font-size: 1.5em;\n}\nh2 {\n  font-size: 1.2em;\n}\n我们的交互式的文本尺寸按钮可以修改 body 元素的 font-size 属性，而由于我们使用相对的单位，页面中的其它元素也会相应地调整。\n\n以下是 JavaScript：\n\nfunction makeSizer(size) {\n  return function() {\n    document.body.style.fontSize = size + 'px';\n  };\n}\n\nvar size12 = makeSizer(12);\nvar size14 = makeSizer(14);\nvar size16 = makeSizer(16);\nsize12，size14 和 size16 为将 body 文本相应地调整为 12，14，16 像素的函数。我们可以将它们分别添加到按钮上（这里是链接）。如下所示：\n\ndocument.getElementById('size-12').onclick = size12;\ndocument.getElementById('size-14').onclick = size14;\ndocument.getElementById('size-16').onclick = size16;\n<a href=\"#\" id=\"size-12\">12</a>\n<a href=\"#\" id=\"size-14\">14</a>\n<a href=\"#\" id=\"size-16\">16</a>\n\n\n \n\n用闭包模拟私有方法\n诸如 Java 在内的一些语言支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。\n\n对此，JavaScript 并不提供原生的支持，但是可以使用闭包模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。\n\n下面的示例展现了如何使用闭包来定义公共函数，且其可以访问私有函数和变量。这个方式也称为 模块模式（module pattern）：\n\nvar Counter = (function() {\n  var privateCounter = 0;\n  function changeBy(val) {\n    privateCounter += val;\n  }\n  return {\n    increment: function() {\n      changeBy(1);\n    },\n    decrement: function() {\n      changeBy(-1);\n    },\n    value: function() {\n      return privateCounter;\n    }\n  }   \n})();\n\nconsole.log(Counter.value()); /* logs 0 */\nCounter.increment();\nCounter.increment();\nconsole.log(Counter.value()); /* logs 2 */\nCounter.decrement();\nconsole.log(Counter.value()); /* logs 1 */\n这里有很多细节。在以往的示例中，每个闭包都有它自己的环境；而这次我们只创建了一个环境，为三个函数所共享：Counter.increment，Counter.decrement 和 Counter.value。\n\n该共享环境创建于一个匿名函数体内，该函数一经定义立刻执行。环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。 这两项都无法在匿名函数外部直接访问。必须通过匿名包装器返回的三个公共函数访问。\n\n这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法范围的作用域，它们都可以访问 privateCounter 变量和 changeBy 函数。\n\n您应该注意到了，我们定义了一个匿名函数用于创建计数器，然后直接调用该函数，并将返回值赋给 Counter 变量。也可以将这个函数保存到另一个变量中，以便创建多个计数器。\n\nvar makeCounter = function() {\n  var privateCounter = 0;\n  function changeBy(val) {\n    privateCounter += val;\n  }\n  return {\n    increment: function() {\n      changeBy(1);\n    },\n    decrement: function() {\n      changeBy(-1);\n    },\n    value: function() {\n      return privateCounter;\n    }\n  }  \n};\n\nvar Counter1 = makeCounter();\nvar Counter2 = makeCounter();\nconsole.log(Counter1.value()); /* logs 0 */\nCounter1.increment();\nCounter1.increment();\nconsole.log(Counter1.value()); /* logs 2 */\nCounter1.decrement();\nconsole.log(Counter1.value()); /* logs 1 */\nconsole.log(Counter2.value()); /* logs 0 */\n请注意两个计数器是如何维护它们各自的独立性的。每次调用 makeCounter() 函数期间，其环境是不同的。每次调用中， privateCounter 中含有不同的实例。\n\n这种形式的闭包提供了许多通常由面向对象编程U所享有的益处，尤其是数据隐藏和封装。\n\n在循环中创建闭包：一个常见错误\n在 JavaScript 1.7 引入 let 关键字 之前，闭包的一个常见的问题发生于在循环中创建闭包。参考下面的示例：\n\n<p id=\"help\">Helpful notes will appear here</p>\n<p>E-mail: <input type=\"text\" id=\"email\" name=\"email\"></p>\n<p>Name: <input type=\"text\" id=\"name\" name=\"name\"></p>\n<p>Age: <input type=\"text\" id=\"age\" name=\"age\"></p>\nfunction showHelp(help) {\n  document.getElementById('help').innerHTML = help;\n}\n\nfunction setupHelp() {\n  var helpText = [\n      {'id': 'email', 'help': 'Your e-mail address'},\n      {'id': 'name', 'help': 'Your full name'},\n      {'id': 'age', 'help': 'Your age (you must be over 16)'}\n    ];\n\n  for (var i = 0; i < helpText.length; i++) {\n    var item = helpText[i];\n    document.getElementById(item.id).onfocus = function() {\n      showHelp(item.help);\n    }\n  }\n}\n\nsetupHelp();\n\n\n数组 helpText 中定义了三个有用的提示信息，每一个都关联于对应的文档中的输入域的 ID。通过循环这三项定义，依次为每一个输入域添加了一个 onfocus 事件处理函数，以便显示帮助信息。\n\n运行这段代码后，您会发现它没有达到想要的效果。无论焦点在哪个输入域上，显示的都是关于年龄的消息。\n\n该问题的原因在于赋给 onfocus 是闭包（setupHelp）中的匿名函数而不是闭包对象；在闭包（setupHelp）中一共创建了三个匿名函数，但是它们都共享同一个环境（item）。在 onfocus 的回调被执行时，循环早已经完成，且此时 item 变量（由所有三个闭包所共享）已经指向了 helpText 列表中的最后一项。\n\n解决这个问题的一种方案是使onfocus指向一个新的闭包对象。\n\nfunction showHelp(help) {\n  document.getElementById('help').innerHTML = help;\n}\n\nfunction makeHelpCallback(help) {\n  return function() {\n    showHelp(help);\n  };\n}\n\nfunction setupHelp() {\n  var helpText = [\n      {'id': 'email', 'help': 'Your e-mail address'},\n      {'id': 'name', 'help': 'Your full name'},\n      {'id': 'age', 'help': 'Your age (you must be over 16)'}\n    ];\n\n  for (var i = 0; i < helpText.length; i++) {\n    var item = helpText[i];\n    document.getElementById(item.id).onfocus = makeHelpCallback(item.help);\n  }\n}\n\nsetupHelp();\n\n\n这段代码可以如我们所期望的那样工作。所有的回调不再共享同一个环境， makeHelpCallback 函数为每一个回调创建一个新的环境。在这些环境中，help 指向 helpText 数组中对应的字符串。\n\n性能考量\n如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。\n\n例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用，方法都会被重新赋值一次（也就是说，为每一个对象的创建）。\n\n考虑以下虽然不切实际但却说明问题的示例：\n\nfunction MyObject(name, message) {\n  this.name = name.toString();\n  this.message = message.toString();\n  this.getName = function() {\n    return this.name;\n  };\n\n  this.getMessage = function() {\n    return this.message;\n  };\n}\n上面的代码并未利用到闭包的益处，因此，应该修改为如下常规形式：\n\nfunction MyObject(name, message) {\n  this.name = name.toString();\n  this.message = message.toString();\n}\nMyObject.prototype = {\n  getName: function() {\n    return this.name;\n  },\n  getMessage: function() {\n    return this.message;\n  }\n};\n或者改成：\n\nfunction MyObject(name, message) {\n  this.name = name.toString();\n  this.message = message.toString();\n}\nMyObject.prototype.getName = function() {\n  return this.name;\n};\nMyObject.prototype.getMessage = function() {\n  return this.message;\n};\n在前面的两个示例中，继承的原型可以为所有对象共享，且不必在每一次创建对象时定义方法。参见 对象模型的细节 一章可以了解更为详细的信息。","slug":"闭包","published":1,"updated":"2016-11-02T02:22:49.493Z","_id":"ciuzabcbn0005fv7tspwnrvr4","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"Javascript闭包\"><a href=\"#Javascript闭包\" class=\"headerlink\" title=\"Javascript闭包\"></a>Javascript闭包</h3><p>闭包是指能够访问自由变量的函数 (变量在本地使用，但在闭包中定义)。换句话说，定义在闭包中的函数可以“记忆”它被创建时候的环境。</p>\n<p><strong>先看下面这个函数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> city = <span class=\"string\">\"西安\"</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCity</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(city);</div><div class=\"line\">  &#125;</div><div class=\"line\">  getCity();</div><div class=\"line\">&#125;</div><div class=\"line\">foo();<span class=\"comment\">//控制台输出'西安'</span></div></pre></td></tr></table></figure>\n<p>函数 foo() 创建了一个局部变量 city，然后定义了名为 getCity() 的函数。 getCity() 是一个内部函数——定义于 foo() 之内且仅在该函数体内可用。getCity() 没有任何自己的局部变量，然而它可以访问到外部函数的变量，即可以使用父函数中声明的 city 变量。</p>\n<h4 id=\"一、闭包\"><a href=\"#一、闭包\" class=\"headerlink\" title=\"一、闭包\"></a>一、闭包</h4><p><strong>再看这样一个函数</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> city = <span class=\"string\">\"西安\"</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCity</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(city);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> getCity;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> foo2 = foo1();</div><div class=\"line\">foo2();<span class=\"comment\">//控制台输出西安</span></div></pre></td></tr></table></figure></p>\n<p> 运行这段代码的效果和之前的 foo() 示例完全一样：字符串 “西安” 将被显示在一个 控制台中。其中的不同也是有意思的地方在于 getCity()内部函数在执行前被从其外围函数foo1中返回了。</p>\n<p>这段代码看起来别扭却能正常运行。通常，函数中的局部变量仅在函数的执行期间可用。一旦foo1()执行过后，我们会很合理的认为 city变量将不再可用。虽然代码运行的没问题，但实际并不是这样的。</p>\n<p>这个谜题的答案是foo1变成一个闭包了。闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，foo1是一个闭包，由getCity函数和闭包创建时存在的”西安”字符串形成。</p>\n<p>下面是一个更有意思的示例 — makeAdder 函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeAdder</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x + y;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> add5 = makeAdder(<span class=\"number\">5</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> add10 = makeAdder(<span class=\"number\">10</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(add5(<span class=\"number\">2</span>));  <span class=\"comment\">// 7</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(add10(<span class=\"number\">2</span>)); <span class=\"comment\">// 12</span></div></pre></td></tr></table></figure>\n<p>在这个示例中，我们定义了 makeAdder(x) 函数：带有一个参数 x 并返回一个新的函数。返回的函数带有一个参数 y，并返回 x 和 y 的和。</p>\n<p>从本质上讲，makeAdder 是一个函数工厂 — 创建将指定的值和它的参数求和的函数，在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。</p>\n<p>add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。</p>\n<p>实用的闭包<br>理论就是这些了 — 可是闭包确实有用吗？让我们看看闭包的实践意义。闭包允许将函数与其所操作的某些数据（环境）关连起来。这显然类似于面向对象编程。在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。</p>\n<p>因而，一般说来，可以使用只有一个方法的对象的地方，都可以使用闭包。</p>\n<p>在 Web 中，您可能想这样做的情形非常普遍。大部分我们所写的 Web JavaScript 代码都是事件驱动的 — 定义某种行为，然后将其添加到用户触发的事件之上（比如点击或者按键）。我们的代码通常添加为回调：响应事件而执行的函数。</p>\n<p>以下是一个实际的示例：假设我们想在页面上添加一些可以调整字号的按钮。一种方法是以像素为单位指定 body 元素的 font-size，然后通过相对的 em 单位设置页面中其它元素（例如页眉）的字号：</p>\n<p>body {<br>  font-family: Helvetica, Arial, sans-serif;<br>  font-size: 12px;<br>}</p>\n<p>h1 {<br>  font-size: 1.5em;<br>}<br>h2 {<br>  font-size: 1.2em;<br>}<br>我们的交互式的文本尺寸按钮可以修改 body 元素的 font-size 属性，而由于我们使用相对的单位，页面中的其它元素也会相应地调整。</p>\n<p>以下是 JavaScript：</p>\n<p>function makeSizer(size) {<br>  return function() {<br>    document.body.style.fontSize = size + ‘px’;<br>  };<br>}</p>\n<p>var size12 = makeSizer(12);<br>var size14 = makeSizer(14);<br>var size16 = makeSizer(16);<br>size12，size14 和 size16 为将 body 文本相应地调整为 12，14，16 像素的函数。我们可以将它们分别添加到按钮上（这里是链接）。如下所示：</p>\n<p>document.getElementById(‘size-12’).onclick = size12;<br>document.getElementById(‘size-14’).onclick = size14;<br>document.getElementById(‘size-16’).onclick = size16;<br><a href=\"#\" id=\"size-12\">12</a><br><a href=\"#\" id=\"size-14\">14</a><br><a href=\"#\" id=\"size-16\">16</a></p>\n<p>用闭包模拟私有方法<br>诸如 Java 在内的一些语言支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。</p>\n<p>对此，JavaScript 并不提供原生的支持，但是可以使用闭包模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。</p>\n<p>下面的示例展现了如何使用闭包来定义公共函数，且其可以访问私有函数和变量。这个方式也称为 模块模式（module pattern）：</p>\n<p>var Counter = (function() {<br>  var privateCounter = 0;<br>  function changeBy(val) {<br>    privateCounter += val;<br>  }<br>  return {<br>    increment: function() {<br>      changeBy(1);<br>    },<br>    decrement: function() {<br>      changeBy(-1);<br>    },<br>    value: function() {<br>      return privateCounter;<br>    }<br>  }<br>})();</p>\n<p>console.log(Counter.value()); /<em> logs 0 </em>/<br>Counter.increment();<br>Counter.increment();<br>console.log(Counter.value()); /<em> logs 2 </em>/<br>Counter.decrement();<br>console.log(Counter.value()); /<em> logs 1 </em>/<br>这里有很多细节。在以往的示例中，每个闭包都有它自己的环境；而这次我们只创建了一个环境，为三个函数所共享：Counter.increment，Counter.decrement 和 Counter.value。</p>\n<p>该共享环境创建于一个匿名函数体内，该函数一经定义立刻执行。环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。 这两项都无法在匿名函数外部直接访问。必须通过匿名包装器返回的三个公共函数访问。</p>\n<p>这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法范围的作用域，它们都可以访问 privateCounter 变量和 changeBy 函数。</p>\n<p>您应该注意到了，我们定义了一个匿名函数用于创建计数器，然后直接调用该函数，并将返回值赋给 Counter 变量。也可以将这个函数保存到另一个变量中，以便创建多个计数器。</p>\n<p>var makeCounter = function() {<br>  var privateCounter = 0;<br>  function changeBy(val) {<br>    privateCounter += val;<br>  }<br>  return {<br>    increment: function() {<br>      changeBy(1);<br>    },<br>    decrement: function() {<br>      changeBy(-1);<br>    },<br>    value: function() {<br>      return privateCounter;<br>    }<br>  }<br>};</p>\n<p>var Counter1 = makeCounter();<br>var Counter2 = makeCounter();<br>console.log(Counter1.value()); /<em> logs 0 </em>/<br>Counter1.increment();<br>Counter1.increment();<br>console.log(Counter1.value()); /<em> logs 2 </em>/<br>Counter1.decrement();<br>console.log(Counter1.value()); /<em> logs 1 </em>/<br>console.log(Counter2.value()); /<em> logs 0 </em>/<br>请注意两个计数器是如何维护它们各自的独立性的。每次调用 makeCounter() 函数期间，其环境是不同的。每次调用中， privateCounter 中含有不同的实例。</p>\n<p>这种形式的闭包提供了许多通常由面向对象编程U所享有的益处，尤其是数据隐藏和封装。</p>\n<p>在循环中创建闭包：一个常见错误<br>在 JavaScript 1.7 引入 let 关键字 之前，闭包的一个常见的问题发生于在循环中创建闭包。参考下面的示例：</p>\n<p></p><p id=\"help\">Helpful notes will appear here</p><p></p>\n<p></p><p>E-mail: <input type=\"text\" id=\"email\" name=\"email\"></p><p></p>\n<p></p><p>Name: <input type=\"text\" id=\"name\" name=\"name\"></p><p></p>\n<p></p><p>Age: <input type=\"text\" id=\"age\" name=\"age\"></p><br>function showHelp(help) {<br>  document.getElementById(‘help’).innerHTML = help;<br>}<p></p>\n<p>function setupHelp() {<br>  var helpText = [<br>      {‘id’: ‘email’, ‘help’: ‘Your e-mail address’},<br>      {‘id’: ‘name’, ‘help’: ‘Your full name’},<br>      {‘id’: ‘age’, ‘help’: ‘Your age (you must be over 16)’}<br>    ];</p>\n<p>  for (var i = 0; i &lt; helpText.length; i++) {<br>    var item = helpText[i];<br>    document.getElementById(item.id).onfocus = function() {<br>      showHelp(item.help);<br>    }<br>  }<br>}</p>\n<p>setupHelp();</p>\n<p>数组 helpText 中定义了三个有用的提示信息，每一个都关联于对应的文档中的输入域的 ID。通过循环这三项定义，依次为每一个输入域添加了一个 onfocus 事件处理函数，以便显示帮助信息。</p>\n<p>运行这段代码后，您会发现它没有达到想要的效果。无论焦点在哪个输入域上，显示的都是关于年龄的消息。</p>\n<p>该问题的原因在于赋给 onfocus 是闭包（setupHelp）中的匿名函数而不是闭包对象；在闭包（setupHelp）中一共创建了三个匿名函数，但是它们都共享同一个环境（item）。在 onfocus 的回调被执行时，循环早已经完成，且此时 item 变量（由所有三个闭包所共享）已经指向了 helpText 列表中的最后一项。</p>\n<p>解决这个问题的一种方案是使onfocus指向一个新的闭包对象。</p>\n<p>function showHelp(help) {<br>  document.getElementById(‘help’).innerHTML = help;<br>}</p>\n<p>function makeHelpCallback(help) {<br>  return function() {<br>    showHelp(help);<br>  };<br>}</p>\n<p>function setupHelp() {<br>  var helpText = [<br>      {‘id’: ‘email’, ‘help’: ‘Your e-mail address’},<br>      {‘id’: ‘name’, ‘help’: ‘Your full name’},<br>      {‘id’: ‘age’, ‘help’: ‘Your age (you must be over 16)’}<br>    ];</p>\n<p>  for (var i = 0; i &lt; helpText.length; i++) {<br>    var item = helpText[i];<br>    document.getElementById(item.id).onfocus = makeHelpCallback(item.help);<br>  }<br>}</p>\n<p>setupHelp();</p>\n<p>这段代码可以如我们所期望的那样工作。所有的回调不再共享同一个环境， makeHelpCallback 函数为每一个回调创建一个新的环境。在这些环境中，help 指向 helpText 数组中对应的字符串。</p>\n<p>性能考量<br>如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。</p>\n<p>例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用，方法都会被重新赋值一次（也就是说，为每一个对象的创建）。</p>\n<p>考虑以下虽然不切实际但却说明问题的示例：</p>\n<p>function MyObject(name, message) {<br>  this.name = name.toString();<br>  this.message = message.toString();<br>  this.getName = function() {<br>    return this.name;<br>  };</p>\n<p>  this.getMessage = function() {<br>    return this.message;<br>  };<br>}<br>上面的代码并未利用到闭包的益处，因此，应该修改为如下常规形式：</p>\n<p>function MyObject(name, message) {<br>  this.name = name.toString();<br>  this.message = message.toString();<br>}<br>MyObject.prototype = {<br>  getName: function() {<br>    return this.name;<br>  },<br>  getMessage: function() {<br>    return this.message;<br>  }<br>};<br>或者改成：</p>\n<p>function MyObject(name, message) {<br>  this.name = name.toString();<br>  this.message = message.toString();<br>}<br>MyObject.prototype.getName = function() {<br>  return this.name;<br>};<br>MyObject.prototype.getMessage = function() {<br>  return this.message;<br>};<br>在前面的两个示例中，继承的原型可以为所有对象共享，且不必在每一次创建对象时定义方法。参见 对象模型的细节 一章可以了解更为详细的信息。</p>\n","excerpt":"","more":"<h3 id=\"Javascript闭包\"><a href=\"#Javascript闭包\" class=\"headerlink\" title=\"Javascript闭包\"></a>Javascript闭包</h3><p>闭包是指能够访问自由变量的函数 (变量在本地使用，但在闭包中定义)。换句话说，定义在闭包中的函数可以“记忆”它被创建时候的环境。</p>\n<p><strong>先看下面这个函数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> city = <span class=\"string\">\"西安\"</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCity</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(city);</div><div class=\"line\">  &#125;</div><div class=\"line\">  getCity();</div><div class=\"line\">&#125;</div><div class=\"line\">foo();<span class=\"comment\">//控制台输出'西安'</span></div></pre></td></tr></table></figure>\n<p>函数 foo() 创建了一个局部变量 city，然后定义了名为 getCity() 的函数。 getCity() 是一个内部函数——定义于 foo() 之内且仅在该函数体内可用。getCity() 没有任何自己的局部变量，然而它可以访问到外部函数的变量，即可以使用父函数中声明的 city 变量。</p>\n<h4 id=\"一、闭包\"><a href=\"#一、闭包\" class=\"headerlink\" title=\"一、闭包\"></a>一、闭包</h4><p><strong>再看这样一个函数</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo1</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> city = <span class=\"string\">\"西安\"</span>;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCity</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(city);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> getCity;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> foo2 = foo1();</div><div class=\"line\">foo2();<span class=\"comment\">//控制台输出西安</span></div></pre></td></tr></table></figure></p>\n<p> 运行这段代码的效果和之前的 foo() 示例完全一样：字符串 “西安” 将被显示在一个 控制台中。其中的不同也是有意思的地方在于 getCity()内部函数在执行前被从其外围函数foo1中返回了。</p>\n<p>这段代码看起来别扭却能正常运行。通常，函数中的局部变量仅在函数的执行期间可用。一旦foo1()执行过后，我们会很合理的认为 city变量将不再可用。虽然代码运行的没问题，但实际并不是这样的。</p>\n<p>这个谜题的答案是foo1变成一个闭包了。闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，foo1是一个闭包，由getCity函数和闭包创建时存在的”西安”字符串形成。</p>\n<p>下面是一个更有意思的示例 — makeAdder 函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeAdder</span>(<span class=\"params\">x</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x + y;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> add5 = makeAdder(<span class=\"number\">5</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> add10 = makeAdder(<span class=\"number\">10</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(add5(<span class=\"number\">2</span>));  <span class=\"comment\">// 7</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(add10(<span class=\"number\">2</span>)); <span class=\"comment\">// 12</span></div></pre></td></tr></table></figure>\n<p>在这个示例中，我们定义了 makeAdder(x) 函数：带有一个参数 x 并返回一个新的函数。返回的函数带有一个参数 y，并返回 x 和 y 的和。</p>\n<p>从本质上讲，makeAdder 是一个函数工厂 — 创建将指定的值和它的参数求和的函数，在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。</p>\n<p>add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。</p>\n<p>实用的闭包<br>理论就是这些了 — 可是闭包确实有用吗？让我们看看闭包的实践意义。闭包允许将函数与其所操作的某些数据（环境）关连起来。这显然类似于面向对象编程。在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。</p>\n<p>因而，一般说来，可以使用只有一个方法的对象的地方，都可以使用闭包。</p>\n<p>在 Web 中，您可能想这样做的情形非常普遍。大部分我们所写的 Web JavaScript 代码都是事件驱动的 — 定义某种行为，然后将其添加到用户触发的事件之上（比如点击或者按键）。我们的代码通常添加为回调：响应事件而执行的函数。</p>\n<p>以下是一个实际的示例：假设我们想在页面上添加一些可以调整字号的按钮。一种方法是以像素为单位指定 body 元素的 font-size，然后通过相对的 em 单位设置页面中其它元素（例如页眉）的字号：</p>\n<p>body {<br>  font-family: Helvetica, Arial, sans-serif;<br>  font-size: 12px;<br>}</p>\n<p>h1 {<br>  font-size: 1.5em;<br>}<br>h2 {<br>  font-size: 1.2em;<br>}<br>我们的交互式的文本尺寸按钮可以修改 body 元素的 font-size 属性，而由于我们使用相对的单位，页面中的其它元素也会相应地调整。</p>\n<p>以下是 JavaScript：</p>\n<p>function makeSizer(size) {<br>  return function() {<br>    document.body.style.fontSize = size + ‘px’;<br>  };<br>}</p>\n<p>var size12 = makeSizer(12);<br>var size14 = makeSizer(14);<br>var size16 = makeSizer(16);<br>size12，size14 和 size16 为将 body 文本相应地调整为 12，14，16 像素的函数。我们可以将它们分别添加到按钮上（这里是链接）。如下所示：</p>\n<p>document.getElementById(‘size-12’).onclick = size12;<br>document.getElementById(‘size-14’).onclick = size14;<br>document.getElementById(‘size-16’).onclick = size16;<br><a href=\"#\" id=\"size-12\">12</a><br><a href=\"#\" id=\"size-14\">14</a><br><a href=\"#\" id=\"size-16\">16</a></p>\n<p>用闭包模拟私有方法<br>诸如 Java 在内的一些语言支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。</p>\n<p>对此，JavaScript 并不提供原生的支持，但是可以使用闭包模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。</p>\n<p>下面的示例展现了如何使用闭包来定义公共函数，且其可以访问私有函数和变量。这个方式也称为 模块模式（module pattern）：</p>\n<p>var Counter = (function() {<br>  var privateCounter = 0;<br>  function changeBy(val) {<br>    privateCounter += val;<br>  }<br>  return {<br>    increment: function() {<br>      changeBy(1);<br>    },<br>    decrement: function() {<br>      changeBy(-1);<br>    },<br>    value: function() {<br>      return privateCounter;<br>    }<br>  }<br>})();</p>\n<p>console.log(Counter.value()); /<em> logs 0 </em>/<br>Counter.increment();<br>Counter.increment();<br>console.log(Counter.value()); /<em> logs 2 </em>/<br>Counter.decrement();<br>console.log(Counter.value()); /<em> logs 1 </em>/<br>这里有很多细节。在以往的示例中，每个闭包都有它自己的环境；而这次我们只创建了一个环境，为三个函数所共享：Counter.increment，Counter.decrement 和 Counter.value。</p>\n<p>该共享环境创建于一个匿名函数体内，该函数一经定义立刻执行。环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。 这两项都无法在匿名函数外部直接访问。必须通过匿名包装器返回的三个公共函数访问。</p>\n<p>这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法范围的作用域，它们都可以访问 privateCounter 变量和 changeBy 函数。</p>\n<p>您应该注意到了，我们定义了一个匿名函数用于创建计数器，然后直接调用该函数，并将返回值赋给 Counter 变量。也可以将这个函数保存到另一个变量中，以便创建多个计数器。</p>\n<p>var makeCounter = function() {<br>  var privateCounter = 0;<br>  function changeBy(val) {<br>    privateCounter += val;<br>  }<br>  return {<br>    increment: function() {<br>      changeBy(1);<br>    },<br>    decrement: function() {<br>      changeBy(-1);<br>    },<br>    value: function() {<br>      return privateCounter;<br>    }<br>  }<br>};</p>\n<p>var Counter1 = makeCounter();<br>var Counter2 = makeCounter();<br>console.log(Counter1.value()); /<em> logs 0 </em>/<br>Counter1.increment();<br>Counter1.increment();<br>console.log(Counter1.value()); /<em> logs 2 </em>/<br>Counter1.decrement();<br>console.log(Counter1.value()); /<em> logs 1 </em>/<br>console.log(Counter2.value()); /<em> logs 0 </em>/<br>请注意两个计数器是如何维护它们各自的独立性的。每次调用 makeCounter() 函数期间，其环境是不同的。每次调用中， privateCounter 中含有不同的实例。</p>\n<p>这种形式的闭包提供了许多通常由面向对象编程U所享有的益处，尤其是数据隐藏和封装。</p>\n<p>在循环中创建闭包：一个常见错误<br>在 JavaScript 1.7 引入 let 关键字 之前，闭包的一个常见的问题发生于在循环中创建闭包。参考下面的示例：</p>\n<p><p id=\"help\">Helpful notes will appear here</p></p>\n<p><p>E-mail: <input type=\"text\" id=\"email\" name=\"email\"></p></p>\n<p><p>Name: <input type=\"text\" id=\"name\" name=\"name\"></p></p>\n<p><p>Age: <input type=\"text\" id=\"age\" name=\"age\"></p><br>function showHelp(help) {<br>  document.getElementById(‘help’).innerHTML = help;<br>}</p>\n<p>function setupHelp() {<br>  var helpText = [<br>      {‘id’: ‘email’, ‘help’: ‘Your e-mail address’},<br>      {‘id’: ‘name’, ‘help’: ‘Your full name’},<br>      {‘id’: ‘age’, ‘help’: ‘Your age (you must be over 16)’}<br>    ];</p>\n<p>  for (var i = 0; i &lt; helpText.length; i++) {<br>    var item = helpText[i];<br>    document.getElementById(item.id).onfocus = function() {<br>      showHelp(item.help);<br>    }<br>  }<br>}</p>\n<p>setupHelp();</p>\n<p>数组 helpText 中定义了三个有用的提示信息，每一个都关联于对应的文档中的输入域的 ID。通过循环这三项定义，依次为每一个输入域添加了一个 onfocus 事件处理函数，以便显示帮助信息。</p>\n<p>运行这段代码后，您会发现它没有达到想要的效果。无论焦点在哪个输入域上，显示的都是关于年龄的消息。</p>\n<p>该问题的原因在于赋给 onfocus 是闭包（setupHelp）中的匿名函数而不是闭包对象；在闭包（setupHelp）中一共创建了三个匿名函数，但是它们都共享同一个环境（item）。在 onfocus 的回调被执行时，循环早已经完成，且此时 item 变量（由所有三个闭包所共享）已经指向了 helpText 列表中的最后一项。</p>\n<p>解决这个问题的一种方案是使onfocus指向一个新的闭包对象。</p>\n<p>function showHelp(help) {<br>  document.getElementById(‘help’).innerHTML = help;<br>}</p>\n<p>function makeHelpCallback(help) {<br>  return function() {<br>    showHelp(help);<br>  };<br>}</p>\n<p>function setupHelp() {<br>  var helpText = [<br>      {‘id’: ‘email’, ‘help’: ‘Your e-mail address’},<br>      {‘id’: ‘name’, ‘help’: ‘Your full name’},<br>      {‘id’: ‘age’, ‘help’: ‘Your age (you must be over 16)’}<br>    ];</p>\n<p>  for (var i = 0; i &lt; helpText.length; i++) {<br>    var item = helpText[i];<br>    document.getElementById(item.id).onfocus = makeHelpCallback(item.help);<br>  }<br>}</p>\n<p>setupHelp();</p>\n<p>这段代码可以如我们所期望的那样工作。所有的回调不再共享同一个环境， makeHelpCallback 函数为每一个回调创建一个新的环境。在这些环境中，help 指向 helpText 数组中对应的字符串。</p>\n<p>性能考量<br>如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。</p>\n<p>例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用，方法都会被重新赋值一次（也就是说，为每一个对象的创建）。</p>\n<p>考虑以下虽然不切实际但却说明问题的示例：</p>\n<p>function MyObject(name, message) {<br>  this.name = name.toString();<br>  this.message = message.toString();<br>  this.getName = function() {<br>    return this.name;<br>  };</p>\n<p>  this.getMessage = function() {<br>    return this.message;<br>  };<br>}<br>上面的代码并未利用到闭包的益处，因此，应该修改为如下常规形式：</p>\n<p>function MyObject(name, message) {<br>  this.name = name.toString();<br>  this.message = message.toString();<br>}<br>MyObject.prototype = {<br>  getName: function() {<br>    return this.name;<br>  },<br>  getMessage: function() {<br>    return this.message;<br>  }<br>};<br>或者改成：</p>\n<p>function MyObject(name, message) {<br>  this.name = name.toString();<br>  this.message = message.toString();<br>}<br>MyObject.prototype.getName = function() {<br>  return this.name;<br>};<br>MyObject.prototype.getMessage = function() {<br>  return this.message;<br>};<br>在前面的两个示例中，继承的原型可以为所有对象共享，且不必在每一次创建对象时定义方法。参见 对象模型的细节 一章可以了解更为详细的信息。</p>\n"},{"title":"制作一个进入项目目录的小脚本","date":"2016-07-12T16:00:00.000Z","_content":"\n### 需求 \n&emsp;&emsp;在我的项目文件夹里有四个不同的项目，/app/project/,项目文件夹分别为testa，testb，testc，testd。每次启动ubuntu后我要进入第一个项目就需要运行cd app/project/testa,git statua 。所以需要一个自定义的命令可以是我直接进入指定的项目目录，并执行一次git status。因为我是希望根据我传的参数进入指定的目录，会需要一些判断。所以单纯使用alias有点不太妥当，这里就使用alias 和shell 脚本来实现这个功能。\n\n\n### 写一个简单的shell脚本\n\n1.新建一个into_project.sh文件：\n\t{% codeblock  %}\n\t#!/bin/bash\n\t#声明一个关联数组并赋值\n\tdeclare -A project\n\tproject[a]=~/app/project/testa/\n\tproject[b]=~/app/project/testb/\n\tproject[c]=~/app/project/testc/\n\tproject[d]=~/app/project/testd/ \n\t{% endcodeblock %}\n&emsp;&emsp;至于什么叫关联数组或者关联数组如何定义，请自行google搜索shell脚本的关联数组，在这里使用关联数组是因为需要下标可以是字符串的数组。然后给数组赋值\n\n2.完整代码，实现功能\n\t{% codeblock %}\n\t#!/usr/bin/\n\t#项目目录\n\tdeclare -A project\n\tproject[a]=~/app/project/testa/\n\tproject[b]=~/app/project/testb/\n\tproject[c]=~/app/project/testc/\n\tproject[d]=~/app/project/testd/\n\tfalg=false     #flag默认为false\n\tif [ x$1 != x ]; then      #$1为传进来的参数，这里判断它是否为空\n\t\tfor key in ${(k)project}; do     #循环这个关联数组的key\n\t\t\t \n\t\t\tif [ \"$1\"x = \"$key\"x ]; then   #判断传进来的参数是否和里边的其中一个相等\n\t\t\t\tfalg=true   #如果相等，flag为true\n\t\t\t\tbreak   #结束循环\n\t\t\tfi\n\t\tdone\n\t\tif $falg; then     #如果falg为true 执行这里边的内容\n\t\t\techo \"您已进入$project[$1]项目\" \n\t\t\tcd $project[$1]      #进入刚才找到的那个目录\n\t  \tgit status      #运行git status\n\t  else    #否则，根据传进来的参数没找到对应的项目\n\t  \techo \"没有这个项目，项目列表：\" \n\t  \tfor key in ${(k)project}; do printf \"名称:%-5s %-6s\\n\" $key $project[$key]; done    #遍历project数组并输出，以提示\n\t  fi\n\telse  #如果$1为空，没有传参数\n\t    echo \"请指定一个项目！项目列表：\"\n\t    for key in ${(k)project}; do printf \"名称:%-5s %-6s\\n\" $key $project[$key]; done     #遍历project数组并输出，以提示\n\tfi\n\t{% endcodeblock%}\n### 定义自定义命令 \n1.测试\n&emsp;&emsp;现在需要一个命令来调用这个脚本，当然，可以先测试一下。\n\t{% codeblock %}\n\tusername$ /bin/bash into_project.sh a\n\t{% endcodeblock %}\n&emsp;&emsp;输出如下：\n>   username$\n\t您已进入/home/***/project/testa/项目\n\t位于分支 master\n\t您的分支与上游分支 'origin/master' 一致。\n\t无文件要提交，干净的工作区\n\tusername$\n\n可以发现，脚本运行成功了，但是当前shell并没有进入指定的文夹里，因为运行into_project.sh时，会新启一个shell脚本，执行完毕后关闭，所以需要这么执行：\n\t{% codeblock %}\n\tusername$ source into_project.sh a\n\t{% endcodeblock %}\n&emsp;&emsp;输出如下：\n>   username$\n\t您已进入/home/***/project/testa/项目\n\t位于分支 master\n\t您的分支与上游分支 'origin/master' 一致。\n\t无文件要提交，干净的工作区\n\tusername:~/project/testa/$\n2.定义命令\n&emsp;&emsp;ubuntu可以使用alias来将现有的命令自定义，相当于起了一个别名\n如**alias cl = \"cd project/texta\"**.alias 根本就不支持传递命令行参数。不过，我们可以变通的解决这个问题，即定义函数。\n {% codeblock %}\n into='into() { source /home/zy/into_project.sh ;}; into'\n {% endcodeblock %}\n&emsp;&emsp;但是这个命令在用户关闭shell进程后就失效了。我用的是oh-my-zsh，所以打开**~/.zshrc文件，将刚才的命令添加进去，重启或者source ~/.zshrc,这样这个命令就可以使用了","source":"_posts/into-project-shell.md","raw":"---\ntitle: 制作一个进入项目目录的小脚本\ntags: shell\ndate: 2016/7/13 \n---\n\n### 需求 \n&emsp;&emsp;在我的项目文件夹里有四个不同的项目，/app/project/,项目文件夹分别为testa，testb，testc，testd。每次启动ubuntu后我要进入第一个项目就需要运行cd app/project/testa,git statua 。所以需要一个自定义的命令可以是我直接进入指定的项目目录，并执行一次git status。因为我是希望根据我传的参数进入指定的目录，会需要一些判断。所以单纯使用alias有点不太妥当，这里就使用alias 和shell 脚本来实现这个功能。\n\n\n### 写一个简单的shell脚本\n\n1.新建一个into_project.sh文件：\n\t{% codeblock  %}\n\t#!/bin/bash\n\t#声明一个关联数组并赋值\n\tdeclare -A project\n\tproject[a]=~/app/project/testa/\n\tproject[b]=~/app/project/testb/\n\tproject[c]=~/app/project/testc/\n\tproject[d]=~/app/project/testd/ \n\t{% endcodeblock %}\n&emsp;&emsp;至于什么叫关联数组或者关联数组如何定义，请自行google搜索shell脚本的关联数组，在这里使用关联数组是因为需要下标可以是字符串的数组。然后给数组赋值\n\n2.完整代码，实现功能\n\t{% codeblock %}\n\t#!/usr/bin/\n\t#项目目录\n\tdeclare -A project\n\tproject[a]=~/app/project/testa/\n\tproject[b]=~/app/project/testb/\n\tproject[c]=~/app/project/testc/\n\tproject[d]=~/app/project/testd/\n\tfalg=false     #flag默认为false\n\tif [ x$1 != x ]; then      #$1为传进来的参数，这里判断它是否为空\n\t\tfor key in ${(k)project}; do     #循环这个关联数组的key\n\t\t\t \n\t\t\tif [ \"$1\"x = \"$key\"x ]; then   #判断传进来的参数是否和里边的其中一个相等\n\t\t\t\tfalg=true   #如果相等，flag为true\n\t\t\t\tbreak   #结束循环\n\t\t\tfi\n\t\tdone\n\t\tif $falg; then     #如果falg为true 执行这里边的内容\n\t\t\techo \"您已进入$project[$1]项目\" \n\t\t\tcd $project[$1]      #进入刚才找到的那个目录\n\t  \tgit status      #运行git status\n\t  else    #否则，根据传进来的参数没找到对应的项目\n\t  \techo \"没有这个项目，项目列表：\" \n\t  \tfor key in ${(k)project}; do printf \"名称:%-5s %-6s\\n\" $key $project[$key]; done    #遍历project数组并输出，以提示\n\t  fi\n\telse  #如果$1为空，没有传参数\n\t    echo \"请指定一个项目！项目列表：\"\n\t    for key in ${(k)project}; do printf \"名称:%-5s %-6s\\n\" $key $project[$key]; done     #遍历project数组并输出，以提示\n\tfi\n\t{% endcodeblock%}\n### 定义自定义命令 \n1.测试\n&emsp;&emsp;现在需要一个命令来调用这个脚本，当然，可以先测试一下。\n\t{% codeblock %}\n\tusername$ /bin/bash into_project.sh a\n\t{% endcodeblock %}\n&emsp;&emsp;输出如下：\n>   username$\n\t您已进入/home/***/project/testa/项目\n\t位于分支 master\n\t您的分支与上游分支 'origin/master' 一致。\n\t无文件要提交，干净的工作区\n\tusername$\n\n可以发现，脚本运行成功了，但是当前shell并没有进入指定的文夹里，因为运行into_project.sh时，会新启一个shell脚本，执行完毕后关闭，所以需要这么执行：\n\t{% codeblock %}\n\tusername$ source into_project.sh a\n\t{% endcodeblock %}\n&emsp;&emsp;输出如下：\n>   username$\n\t您已进入/home/***/project/testa/项目\n\t位于分支 master\n\t您的分支与上游分支 'origin/master' 一致。\n\t无文件要提交，干净的工作区\n\tusername:~/project/testa/$\n2.定义命令\n&emsp;&emsp;ubuntu可以使用alias来将现有的命令自定义，相当于起了一个别名\n如**alias cl = \"cd project/texta\"**.alias 根本就不支持传递命令行参数。不过，我们可以变通的解决这个问题，即定义函数。\n {% codeblock %}\n into='into() { source /home/zy/into_project.sh ;}; into'\n {% endcodeblock %}\n&emsp;&emsp;但是这个命令在用户关闭shell进程后就失效了。我用的是oh-my-zsh，所以打开**~/.zshrc文件，将刚才的命令添加进去，重启或者source ~/.zshrc,这样这个命令就可以使用了","slug":"into-project-shell","published":1,"updated":"2016-11-02T02:22:20.285Z","_id":"ciuzbcdm00000307taaek54l4","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><p>&emsp;&emsp;在我的项目文件夹里有四个不同的项目，/app/project/,项目文件夹分别为testa，testb，testc，testd。每次启动ubuntu后我要进入第一个项目就需要运行cd app/project/testa,git statua 。所以需要一个自定义的命令可以是我直接进入指定的项目目录，并执行一次git status。因为我是希望根据我传的参数进入指定的目录，会需要一些判断。所以单纯使用alias有点不太妥当，这里就使用alias 和shell 脚本来实现这个功能。</p>\n<h3 id=\"写一个简单的shell脚本\"><a href=\"#写一个简单的shell脚本\" class=\"headerlink\" title=\"写一个简单的shell脚本\"></a>写一个简单的shell脚本</h3><p>1.新建一个into_project.sh文件：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/bash</div><div class=\"line\">#声明一个关联数组并赋值</div><div class=\"line\">declare -A project</div><div class=\"line\">project[a]=~/app/project/testa/</div><div class=\"line\">project[b]=~/app/project/testb/</div><div class=\"line\">project[c]=~/app/project/testc/</div><div class=\"line\">project[d]=~/app/project/testd/ </div></pre></td></tr></table></figure><br>&emsp;&emsp;至于什么叫关联数组或者关联数组如何定义，请自行google搜索shell脚本的关联数组，在这里使用关联数组是因为需要下标可以是字符串的数组。然后给数组赋值</p>\n<p>2.完整代码，实现功能<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/usr/bin/</div><div class=\"line\">#项目目录</div><div class=\"line\">declare -A project</div><div class=\"line\">project[a]=~/app/project/testa/</div><div class=\"line\">project[b]=~/app/project/testb/</div><div class=\"line\">project[c]=~/app/project/testc/</div><div class=\"line\">project[d]=~/app/project/testd/</div><div class=\"line\">falg=false     #flag默认为false</div><div class=\"line\">if [ x$1 != x ]; then      #$1为传进来的参数，这里判断它是否为空</div><div class=\"line\">\tfor key in $&#123;(k)project&#125;; do     #循环这个关联数组的key</div><div class=\"line\">\t\t </div><div class=\"line\">\t\tif [ &quot;$1&quot;x = &quot;$key&quot;x ]; then   #判断传进来的参数是否和里边的其中一个相等</div><div class=\"line\">\t\t\tfalg=true   #如果相等，flag为true</div><div class=\"line\">\t\t\tbreak   #结束循环</div><div class=\"line\">\t\tfi</div><div class=\"line\">\tdone</div><div class=\"line\">\tif $falg; then     #如果falg为true 执行这里边的内容</div><div class=\"line\">\t\techo &quot;您已进入$project[$1]项目&quot; </div><div class=\"line\">\t\tcd $project[$1]      #进入刚才找到的那个目录</div><div class=\"line\">  \tgit status      #运行git status</div><div class=\"line\">  else    #否则，根据传进来的参数没找到对应的项目</div><div class=\"line\">  \techo &quot;没有这个项目，项目列表：&quot; </div><div class=\"line\">  \tfor key in $&#123;(k)project&#125;; do printf &quot;名称:%-5s %-6s\\n&quot; $key $project[$key]; done    #遍历project数组并输出，以提示</div><div class=\"line\">  fi</div><div class=\"line\">else  #如果$1为空，没有传参数</div><div class=\"line\">    echo &quot;请指定一个项目！项目列表：&quot;</div><div class=\"line\">    for key in $&#123;(k)project&#125;; do printf &quot;名称:%-5s %-6s\\n&quot; $key $project[$key]; done     #遍历project数组并输出，以提示</div><div class=\"line\">fi</div></pre></td></tr></table></figure></p>\n<h3 id=\"定义自定义命令\"><a href=\"#定义自定义命令\" class=\"headerlink\" title=\"定义自定义命令\"></a>定义自定义命令</h3><p>1.测试<br>&emsp;&emsp;现在需要一个命令来调用这个脚本，当然，可以先测试一下。<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">username$ /bin/bash into_project.sh a</div></pre></td></tr></table></figure><br>&emsp;&emsp;输出如下：</p>\n<blockquote>\n<p>  username$<br>    您已进入/home/<em>*</em>/project/testa/项目<br>    位于分支 master<br>    您的分支与上游分支 ‘origin/master’ 一致。<br>    无文件要提交，干净的工作区<br>    username$</p>\n</blockquote>\n<p>可以发现，脚本运行成功了，但是当前shell并没有进入指定的文夹里，因为运行into_project.sh时，会新启一个shell脚本，执行完毕后关闭，所以需要这么执行：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">username$ source into_project.sh a</div></pre></td></tr></table></figure><br>&emsp;&emsp;输出如下：</p>\n<blockquote>\n<p>  username$<br>    您已进入/home/<strong>*/project/testa/项目<br>    位于分支 master<br>    您的分支与上游分支 ‘origin/master’ 一致。<br>    无文件要提交，干净的工作区<br>    username:~/project/testa/$<br>2.定义命令<br>&emsp;&emsp;ubuntu可以使用alias来将现有的命令自定义，相当于起了一个别名<br>如</strong>alias cl = “cd project/texta”<strong>.alias 根本就不支持传递命令行参数。不过，我们可以变通的解决这个问题，即定义函数。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">into=&apos;into() &#123; source /home/zy/into_project.sh ;&#125;; into&apos;</div></pre></td></tr></table></figure><br>&emsp;&emsp;但是这个命令在用户关闭shell进程后就失效了。我用的是oh-my-zsh，所以打开</strong>~/.zshrc文件，将刚才的命令添加进去，重启或者source ~/.zshrc,这样这个命令就可以使用了</p>\n</blockquote>\n","excerpt":"","more":"<h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><p>&emsp;&emsp;在我的项目文件夹里有四个不同的项目，/app/project/,项目文件夹分别为testa，testb，testc，testd。每次启动ubuntu后我要进入第一个项目就需要运行cd app/project/testa,git statua 。所以需要一个自定义的命令可以是我直接进入指定的项目目录，并执行一次git status。因为我是希望根据我传的参数进入指定的目录，会需要一些判断。所以单纯使用alias有点不太妥当，这里就使用alias 和shell 脚本来实现这个功能。</p>\n<h3 id=\"写一个简单的shell脚本\"><a href=\"#写一个简单的shell脚本\" class=\"headerlink\" title=\"写一个简单的shell脚本\"></a>写一个简单的shell脚本</h3><p>1.新建一个into_project.sh文件：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/bin/bash</div><div class=\"line\">#声明一个关联数组并赋值</div><div class=\"line\">declare -A project</div><div class=\"line\">project[a]=~/app/project/testa/</div><div class=\"line\">project[b]=~/app/project/testb/</div><div class=\"line\">project[c]=~/app/project/testc/</div><div class=\"line\">project[d]=~/app/project/testd/ </div></pre></td></tr></table></figure><br>&emsp;&emsp;至于什么叫关联数组或者关联数组如何定义，请自行google搜索shell脚本的关联数组，在这里使用关联数组是因为需要下标可以是字符串的数组。然后给数组赋值</p>\n<p>2.完整代码，实现功能<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">#!/usr/bin/</div><div class=\"line\">#项目目录</div><div class=\"line\">declare -A project</div><div class=\"line\">project[a]=~/app/project/testa/</div><div class=\"line\">project[b]=~/app/project/testb/</div><div class=\"line\">project[c]=~/app/project/testc/</div><div class=\"line\">project[d]=~/app/project/testd/</div><div class=\"line\">falg=false     #flag默认为false</div><div class=\"line\">if [ x$1 != x ]; then      #$1为传进来的参数，这里判断它是否为空</div><div class=\"line\">\tfor key in $&#123;(k)project&#125;; do     #循环这个关联数组的key</div><div class=\"line\">\t\t </div><div class=\"line\">\t\tif [ &quot;$1&quot;x = &quot;$key&quot;x ]; then   #判断传进来的参数是否和里边的其中一个相等</div><div class=\"line\">\t\t\tfalg=true   #如果相等，flag为true</div><div class=\"line\">\t\t\tbreak   #结束循环</div><div class=\"line\">\t\tfi</div><div class=\"line\">\tdone</div><div class=\"line\">\tif $falg; then     #如果falg为true 执行这里边的内容</div><div class=\"line\">\t\techo &quot;您已进入$project[$1]项目&quot; </div><div class=\"line\">\t\tcd $project[$1]      #进入刚才找到的那个目录</div><div class=\"line\">  \tgit status      #运行git status</div><div class=\"line\">  else    #否则，根据传进来的参数没找到对应的项目</div><div class=\"line\">  \techo &quot;没有这个项目，项目列表：&quot; </div><div class=\"line\">  \tfor key in $&#123;(k)project&#125;; do printf &quot;名称:%-5s %-6s\\n&quot; $key $project[$key]; done    #遍历project数组并输出，以提示</div><div class=\"line\">  fi</div><div class=\"line\">else  #如果$1为空，没有传参数</div><div class=\"line\">    echo &quot;请指定一个项目！项目列表：&quot;</div><div class=\"line\">    for key in $&#123;(k)project&#125;; do printf &quot;名称:%-5s %-6s\\n&quot; $key $project[$key]; done     #遍历project数组并输出，以提示</div><div class=\"line\">fi</div></pre></td></tr></table></figure></p>\n<h3 id=\"定义自定义命令\"><a href=\"#定义自定义命令\" class=\"headerlink\" title=\"定义自定义命令\"></a>定义自定义命令</h3><p>1.测试<br>&emsp;&emsp;现在需要一个命令来调用这个脚本，当然，可以先测试一下。<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">username$ /bin/bash into_project.sh a</div></pre></td></tr></table></figure><br>&emsp;&emsp;输出如下：</p>\n<blockquote>\n<p>  username$<br>    您已进入/home/<em>*</em>/project/testa/项目<br>    位于分支 master<br>    您的分支与上游分支 ‘origin/master’ 一致。<br>    无文件要提交，干净的工作区<br>    username$</p>\n</blockquote>\n<p>可以发现，脚本运行成功了，但是当前shell并没有进入指定的文夹里，因为运行into_project.sh时，会新启一个shell脚本，执行完毕后关闭，所以需要这么执行：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">username$ source into_project.sh a</div></pre></td></tr></table></figure><br>&emsp;&emsp;输出如下：</p>\n<blockquote>\n<p>  username$<br>    您已进入/home/<strong>*/project/testa/项目<br>    位于分支 master<br>    您的分支与上游分支 ‘origin/master’ 一致。<br>    无文件要提交，干净的工作区<br>    username:~/project/testa/$<br>2.定义命令<br>&emsp;&emsp;ubuntu可以使用alias来将现有的命令自定义，相当于起了一个别名<br>如</strong>alias cl = “cd project/texta”<strong>.alias 根本就不支持传递命令行参数。不过，我们可以变通的解决这个问题，即定义函数。<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">into=&apos;into() &#123; source /home/zy/into_project.sh ;&#125;; into&apos;</div></pre></td></tr></table></figure><br>&emsp;&emsp;但是这个命令在用户关闭shell进程后就失效了。我用的是oh-my-zsh，所以打开</strong>~/.zshrc文件，将刚才的命令添加进去，重启或者source ~/.zshrc,这样这个命令就可以使用了</p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ciuzabcba0000fv7tu85213fi","tag_id":"ciuzabcbi0002fv7txngkmn65","_id":"ciuzabcbj0003fv7tt8wu67ib"},{"post_id":"ciuzabcbl0004fv7tl139l4wr","tag_id":"ciuzabcbo0006fv7ta3nlbjhh","_id":"ciuzabcbp0008fv7tbxsfbitl"},{"post_id":"ciuzabcbn0005fv7tspwnrvr4","tag_id":"ciuzabcbp0007fv7t9hpbtety","_id":"ciuzabcbp0009fv7tx973c0b2"},{"post_id":"ciuzbcdm00000307taaek54l4","tag_id":"ciuzbcdm80001307t0ecahxrb","_id":"ciuzbcdmd0002307tn17w0vz9"}],"Tag":[{"name":"git","_id":"ciuzabcbi0002fv7txngkmn65"},{"name":"其他","_id":"ciuzabcbo0006fv7ta3nlbjhh"},{"name":"javascript","_id":"ciuzabcbp0007fv7t9hpbtety"},{"name":"shell","_id":"ciuzbcdm80001307t0ecahxrb"}]}}