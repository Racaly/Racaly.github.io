<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[事件委托]]></title>
      <url>http://Racaly.coding.me/2018/02/03/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
      <content type="html"><![CDATA[<h3 id="什么是事件委托"><a href="#什么是事件委托" class="headerlink" title="什么是事件委托"></a>什么是事件委托</h3><p>事件委托也称事件代理，是指通过事件冒泡的原理，只指定一个事件处理程序，来管理同类型的的所有事件。如下html，如果不用事件委托，将每一个li都去添加click事件监听，非常麻烦。另外就是如果通过js动态创建的子节点，需要重新绑定事件。而利用事件委托的话，只需要给父级绑定一个事件监听，即可让每个li都绑定上相应的事件。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>如下html，点击每一个li，弹出其里面的text。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果不用事件委托，将需要为每一个li添加onclick事件或者为其添加click事件监听，假设li元素如果是动态的添加或者删除，你可能将不得不监听他们的新增或者删除事件。</p>
<h3 id="为什么要使用事件委托"><a href="#为什么要使用事件委托" class="headerlink" title="为什么要使用事件委托"></a>为什么要使用事件委托</h3><p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间。如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能。</p>
<h3 id="事件委托的实现"><a href="#事件委托的实现" class="headerlink" title="事件委托的实现"></a>事件委托的实现</h3><p>依然是上面的例子，我们只需监听li的父级的click事件即可<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> ul =<span class="built_in">document</span>.getElementById(<span class="string">"wrap"</span>);</span><br><span class="line">	ul.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> target = e.target;</span><br><span class="line">		<span class="keyword">if</span>(target.nodeName.toLowerCase() == <span class="string">'li'</span>)&#123;</span><br><span class="line">			alert(target.innerHTML);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="target是什么"><a href="#target是什么" class="headerlink" title="target是什么"></a>target是什么</h3><p>Event对象提供了一个属性叫target，可以返回事件的目标节点（事件源），如生成事件的元素、文档或窗口。</p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac 终端命令大全]]></title>
      <url>http://Racaly.coding.me/2018/01/04/mac_terminal_command/</url>
      <content type="html"><![CDATA[<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><table>
<thead>
<tr>
<th style="text-align:left">命令名</th>
<th style="text-align:left">功能描述</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ls</td>
<td style="text-align:left">2</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">cd</td>
<td style="text-align:left">2</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">ll</td>
<td style="text-align:left">2</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">mkdir</td>
<td style="text-align:left">2</td>
<td style="text-align:left">2</td>
</tr>
</tbody>
</table>
]]></content>
      
        
        <tags>
            
            <tag> macOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[event loop]]></title>
      <url>http://Racaly.coding.me/2018/01/03/event%20loop/</url>
      <content type="html"><![CDATA[<h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>相信做前端的大部分同学都知道JavaScript是一门单线程的语言，也就是说它在同一时间只能干一件事。而JavaScript之所以是单线程的又与它的用途有关，JavaScript最初是运行在浏览器上的脚本语言，用来和用户交互以及完成dom操作。比如假使它是多线程的，那么同一时间内如果它同时对同一个dom有相同类型但不同结果的操作，那么将会导致一些无法想象的错误。而在HTML5 的Web Worker标准中，允许JavaScript建立多个子线程，但是子线程必须完全受唯一的主线程控制，并且不得操作dom，如AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程。所以归根到底，JavaScript还是一门单线程的语言。但是在实际开发中我们常常不得不需要同一时间去完成很多任务，比如在渲染dom的同时发起一个ajax请求，我们将这种行为称之为异步，但它并不是多线程，那如何去理解异步就要了解eventloop————事件循环。</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">bar</span>(<span class="params">args...</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果函数bar返回的时候，调用者就能够得到预期结果，那么这个函数就是同步的,否则就是异步。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步</span></span><br><span class="line"><span class="keyword">var</span> bar;</span><br><span class="line">bar = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">	a +=b</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bar(<span class="number">2</span>)) <span class="comment">// 5</span></span><br><span class="line"><span class="comment">//异步</span></span><br><span class="line"><span class="keyword">var</span> bar;</span><br><span class="line">bar = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		a +=b</span><br><span class="line">	&#125;)</span><br><span class="line">	a +=b</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bar(<span class="number">2</span>)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p> 在单线程中，所有的任务需要排队，只有上一个任务完成并释放，才能进行下一个任务，无论上一个任务的用时有多长。这这样就出现了一个问题，如果此时的执行的任务花费的CPU的计算量很大，那我们确实不得不等待计算机在完成这个任务之后再去执行下一个任务，但是如果本次任务只是花费了CPU很少一部分的计算量，那么由于单线程的缘故我们依然不得不等待本次任务执行完毕才能继续下一个任务。所以就有了同步任务和异步任务，</p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[macOS 安装python3和pip]]></title>
      <url>http://Racaly.coding.me/2018/01/02/python3%20install/</url>
      <content type="html"><![CDATA[<p>前不久微信开始流行跳一跳小游戏，在体验了几次之后就发现已经有大神写了一个<a href="https://github.com/wangshub/wechat_jump_game" target="_blank" rel="noopener">python的脚本</a>，于是迫不及待的copy下来，想要横扫朋友圈。克隆下来以后发现需要python3的环境。但是mac默认的python是2.7，所以需要自行安装python3(建议还是不要试图去升级系统自带的python,我已经试过了，虽然升级成功，但是mac系统用的是2.7版本的，升级后会出现一些问题，我最后也是恢复到原来的版本了)</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>python3</span><br></pre></td></tr></table></figure>
<p>如果没有报错，那么就是安装成功了，这里提供一下本人安装时的报错处理，当然，也是借鉴别人的，我又不会，哪里知道那么多</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Already downloaded: /Users/racaly/Library/Caches/Homebrew/python3--wheel<span class="string">-0</span>.30.0.tar.gz</span><br><span class="line"><span class="keyword">Error: </span>An unexpected error occurred during the `brew link` step</span><br><span class="line">The formula built, but is not symlinked into /usr/local</span><br><span class="line">Permission denied @ dir_s_mkdir - /usr/local/Frameworks</span><br><span class="line"><span class="keyword">Error: </span>Permission denied @ dir_s_mkdir - /usr/local/Frameworks</span><br></pre></td></tr></table></figure>
<p>意思好像就是<strong>/usr/local/Frameworks</strong>没权限。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown <span class="variable">$(</span>whoami)<span class="symbol">:admin</span> /usr/local/Frameworks</span><br></pre></td></tr></table></figure></p>
<p>提示没有<strong>Frameworks</strong>这个文件夹<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /usr/<span class="built_in">local</span>/Frameworks</span><br></pre></td></tr></table></figure></p>
<p>然后在运行上面的命令，最后再运行<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>link python3</span><br></pre></td></tr></table></figure></p>
<p>如果没有报错就安装成功了：）</p>
<h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a>pip安装</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> easy_install pip</span><br></pre></td></tr></table></figure>
<p>或者下载<a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="noopener">get-pip.py</a>,然后：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python</span> <span class="built_in">get</span>-pip.<span class="keyword">py</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[node-sass安装失败的解决办法]]></title>
      <url>http://Racaly.coding.me/2017/02/12/install-node-sass/</url>
      <content type="html"><![CDATA[<p> 在项目中有时会用到sass，但是安装node-sass时总是报错，Google上查了一下，node-sass 时在 node scripts/install 阶段会从 github.com 上下载一个 .node 文件。因为github Releases里的文件都托管在s3.amazonaws.com上，这个网址在国内很不稳定，经常下载失败，所以我们可以切换到淘宝镜像来解决这个问题。</p>
<h3 id="直接使用淘宝镜像"><a href="#直接使用淘宝镜像" class="headerlink" title="直接使用淘宝镜像"></a>直接使用淘宝镜像</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SASS_BINARY_SITE=</span>https://npm.taobao.org/mirrors/<span class="keyword">node</span><span class="title">-sass</span>/ npm install <span class="keyword">node</span><span class="title">-sass</span></span><br></pre></td></tr></table></figure>
<p>但是这样的话如果每次<strong>npm install</strong>时node-sass都会安装失败，需要用上述方法单独安装node-sass。<br>因此你可以在项目根目录创建文件<strong>.npmrc</strong>。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sass_binary_site=</span>https://npm.taobao.org/mirrors/<span class="keyword">node</span><span class="title">-sass</span>/</span><br></pre></td></tr></table></figure></p>
<p>这样在<strong>npm i</strong>时node-sass就会安装成功了。</p>
]]></content>
      
        <categories>
            
            <category> npm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> npm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[$localhost用法]]></title>
      <url>http://Racaly.coding.me/2016/12/01/angular1_1/</url>
      <content type="html"><![CDATA[<h3 id="localhost"><a href="#localhost" class="headerlink" title="$localhost"></a>$localhost</h3><h4 id="只读方法"><a href="#只读方法" class="headerlink" title="只读方法"></a>只读方法</h4><p><strong>$localhost.absUrl()</strong><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/<span class="regexp">/当前url 　　http:/</span><span class="regexp">/racaly.coding.me/</span><span class="number">2016</span>/<span class="number">12</span>/<span class="number">01</span>/angular1_1/</span><br><span class="line">var absUrl = <span class="variable">$location</span>.absUrl();</span><br><span class="line">/<span class="regexp">/(结果) =&gt; "http:/</span><span class="regexp">/racaly.coding.me/</span><span class="number">2016</span>/<span class="number">12</span>/<span class="number">01</span>/angular1_1/<span class="string">"</span></span><br></pre></td></tr></table></figure></p>
<p><strong>$localhost.protocol()</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前url 　　http://racaly.coding.me</span></span><br><span class="line"><span class="keyword">var</span> aprotocolUrl = $location.protocol();</span><br><span class="line"><span class="comment">//(结果) =&gt; "http"</span></span><br></pre></td></tr></table></figure></p>
<p><strong>$localhost.host()</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前url 　　http://racaly.coding.me/2016/12/01/angular1_1/</span></span><br><span class="line"><span class="keyword">var</span> hostUrl = $location.host();</span><br><span class="line"><span class="comment">//(结果) =&gt; "racaly.coding.me"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当前url 　　http://racaly.coding.me@mail.com:8008/#/some/par?name=tomangular1_1/</span></span><br><span class="line"><span class="keyword">var</span> hostUrl = $location.host();</span><br><span class="line"><span class="comment">//(结果) =&gt; "mail.com"</span></span><br><span class="line"><span class="keyword">var</span> hostUrl = $location.host;</span><br><span class="line"><span class="comment">//(结果) =&gt; "mail.com:8008"</span></span><br></pre></td></tr></table></figure></p>
<p><strong>$localhost.port()</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前url 　　http://racaly.coding.me@mail.com:8008</span></span><br><span class="line"><span class="keyword">var</span> portUrl = $location.port();</span><br><span class="line"><span class="comment">//(结果) =&gt; "8008"</span></span><br></pre></td></tr></table></figure></p>
<h5 id="读写方法"><a href="#读写方法" class="headerlink" title="读写方法"></a>读写方法</h5><p><strong>$localhost.url([url])</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前url 　　http://racaly.coding.me/soom/angular1_1?name=tom&amp;age=12</span></span><br><span class="line"><span class="keyword">var</span> absUrl = $location.url();</span><br><span class="line"><span class="comment">//(结果) =&gt; "/2016/12/01/angular1_1?name=tom&amp;age=12"</span></span><br></pre></td></tr></table></figure></p>
<p><strong>$localhost.path([path])</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前url 　　http://racaly.coding.me/soom/angular1_1?name=tom&amp;age=12</span></span><br><span class="line"><span class="keyword">var</span> pathUrl = $location.path();</span><br><span class="line"><span class="comment">//(结果) =&gt; "/soom/angular1_1?name=tom&amp;age=12"</span></span><br></pre></td></tr></table></figure></p>
<p><strong>$localhost.search([path])</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前url 　　http://racaly.coding.me/soom/angular1_1?name=tom&amp;age=12</span></span><br><span class="line"><span class="keyword">var</span> searchUrl = $location.search();</span><br><span class="line"><span class="comment">//(结果) =&gt; "/soom/angular1_1?name=tom&amp;age=12"</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> angular1学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> angular </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用git命令]]></title>
      <url>http://Racaly.coding.me/2016/11/24/git_command_list/</url>
      <content type="html"><![CDATA[<h3 id="新建代码仓库"><a href="#新建代码仓库" class="headerlink" title="新建代码仓库"></a>新建代码仓库</h3><ul>
<li>在当前目录新建一个Git代码库<br>$ git init</li>
<li>新建一个目录，将其初始化为Git代码库<br>$ git init [project-name]</li>
<li>下载一个项目和它的整个代码历史<br>$ git clone [url]</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><strong>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</strong></p>
<ul>
<li>显示当前的Git配置<br>$ git config –list</li>
<li>编辑Git配置文件<br>$ git config -e [–global]</li>
<li>设置提交代码时的用户信息<br>$ git config [–global] user.name “[name]”<br>$ git config [–global] user.email “[email address]”</li>
</ul>
<h3 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h3><ul>
<li>添加指定文件到暂存区<br>$ git add [file1] [file2] …</li>
<li>添加指定目录到暂存区，包括子目录<br>$ git add [dir]</li>
<li>添加当前目录的所有文件到暂存区<br>$ git add .</li>
<li>添加每个变化前，都会要求确认</li>
<li>对于同一个文件的多处变化，可以实现分次提交<br>$ git add -p</li>
<li>删除工作区文件，并且将这次删除放入暂存区<br>$ git rm [file1] [file2] …</li>
<li>停止追踪指定文件，但该文件会保留在工作区<br>$ git rm –cached [file]</li>
<li>改名文件，并且将这个改名放入暂存区<br>$ git mv [file-original] [file-renamed]</li>
</ul>
<h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><ul>
<li>提交暂存区到仓库区<br>$ git commit -m [message]</li>
<li>提交暂存区的指定文件到仓库区<br>$ git commit [file1] [file2] … -m [message]</li>
<li>提交工作区自上次commit之后的变化，直接到仓库区<br>$ git commit -a</li>
<li>提交时显示所有diff信息<br>$ git commit -v</li>
<li>使用一次新的commit，替代上一次提交</li>
<li>如果代码没有任何新变化，则用来改写上一次commit的提交信息<br>$ git commit –amend -m [message]</li>
<li>重做上一次commit，并包括指定文件的新变化<br>$ git commit –amend [file1] [file2] …</li>
</ul>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ul>
<li>列出所有本地分支<br>$ git branch</li>
<li>列出所有远程分支<br>$ git branch -r</li>
<li>列出所有本地分支和远程分支<br>$ git branch -a</li>
<li>新建一个分支，但依然停留在当前分支<br>$ git branch [branch-name]</li>
<li>新建一个分支，并切换到该分支<br>$ git checkout -b [branch]</li>
<li>新建一个分支，指向指定commit<br>$ git branch [branch] [commit]</li>
<li>新建一个分支，与指定的远程分支建立追踪关系<br>$ git branch –track [branch] [remote-branch]</li>
<li>切换到指定分支，并更新工作区<br>$ git checkout [branch-name]</li>
<li>切换到上一个分支<br>$ git checkout -</li>
<li>建立追踪关系，在现有分支与指定的远程分支之间<br>$ git branch –set-upstream [branch] [remote-branch]</li>
<li>合并指定分支到当前分支<br>$ git merge [branch]</li>
<li>选择一个commit，合并进当前分支<br>$ git cherry-pick [commit]</li>
<li>删除分支<br>$ git branch -d [branch-name]</li>
<li>删除远程分支<br>$ git push origin  :[branch-name]<br>$ git push origin –delete [branch-name]<br>$ git branch -dr [remote/branch]</li>
</ul>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><ul>
<li>列出所有tag<br>$ git tag</li>
<li>新建一个tag在当前commit<br>$ git tag [tag]</li>
<li>新建一个tag在指定commit<br>$ git tag [tag] [commit]</li>
<li>删除本地tag<br>$ git tag -d [tag]</li>
<li>删除远程tag<br>$ git push origin :refs/tags/[tagName]</li>
<li>查看tag信息<br>$ git show [tag]</li>
<li>提交指定tag<br>$ git push [remote] [tag]</li>
<li>提交所有tag<br>$ git push [remote] –tags</li>
<li>新建一个分支，指向某个tag<br>$ git checkout -b [branch] [tag]</li>
</ul>
<h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><ul>
<li>显示有变更的文件<br>$ git status</li>
<li>显示当前分支的版本历史<br>$ git log</li>
<li>显示commit历史，以及每次commit发生变更的文件<br>$ git log –stat</li>
<li>搜索提交历史，根据关键词<br>$ git log -S [keyword]</li>
<li>显示某个commit之后的所有变动，每个commit占据一行<br>$ git log [tag] HEAD –pretty=format:%s</li>
<li>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件<br>$ git log [tag] HEAD –grep feature</li>
<li>显示某个文件的版本历史，包括文件改名<br>$ git log –follow [file]<br>$ git whatchanged [file]</li>
<li>显示指定文件相关的每一次diff<br>$ git log -p [file]</li>
<li>显示过去5次提交<br>$ git log -5 –pretty –oneline</li>
<li>显示所有提交过的用户，按提交次数排序<br>$ git shortlog -sn</li>
<li>显示指定文件是什么人在什么时间修改过<br>$ git blame [file]</li>
<li>显示暂存区和工作区的差异<br>$ git diff</li>
<li>显示暂存区和上一个commit的差异<br>$ git diff –cached [file]</li>
<li>显示工作区与当前分支最新commit之间的差异<br>$ git diff HEAD</li>
<li>显示两次提交之间的差异<br>$ git diff [first-branch]…[second-branch]</li>
<li>显示今天你写了多少行代码<br>$ git diff –shortstat “@{0 day ago}”</li>
<li>显示某次提交的元数据和内容变化<br>$ git show [commit]</li>
<li>显示某次提交发生变化的文件<br>$ git show –name-only [commit]</li>
<li>显示某次提交时，某个文件的内容<br>$ git show [commit]:[filename]</li>
<li>显示当前分支的最近几次提交<br>$ git reflog</li>
</ul>
<h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><ul>
<li>下载远程仓库的所有变动<br>$ git fetch [remote]</li>
<li>显示所有远程仓库<br>$ git remote -v</li>
<li>显示某个远程仓库的信息<br>$ git remote show [remote]</li>
<li>增加一个新的远程仓库，并命名<br>$ git remote add [shortname] [url]</li>
<li>取回远程仓库的变化，并与本地分支合并<br>$ git pull [remote] [branch]</li>
<li>上传本地指定分支到远程仓库<br>$ git push [remote] [branch]</li>
<li>强行推送当前分支到远程仓库，即使有冲突<br>$ git push [remote] –force</li>
<li>推送所有分支到远程仓库<br>$ git push [remote] –all</li>
</ul>
<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><ul>
<li>恢复暂存区的指定文件到工作区<br>$ git checkout [file]</li>
<li>恢复某个commit的指定文件到暂存区和工作区<br>$ git checkout [commit] [file]</li>
<li>恢复暂存区的所有文件到工作区<br>$ git checkout .</li>
<li>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变<br>$ git reset [file]</li>
<li>重置暂存区与工作区，与上一次commit保持一致<br>$ git reset –hard</li>
<li>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变<br>$ git reset [commit]</li>
<li>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致<br>$ git reset –hard [commit]</li>
<li>重置当前HEAD为指定commit，但保持暂存区和工作区不变<br>$ git reset –keep [commit]</li>
<li>新建一个commit，用来撤销指定commit<br>后者的所有变化都将被前者抵消，并且应用到当前分支<br>$ git revert [commit]</li>
<li>暂时将未提交的变化移除，稍后再移入<br>$ git stash<br>$ git stash pop</li>
</ul>
]]></content>
      
        <categories>
            
            <category> git学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu安装ns2]]></title>
      <url>http://Racaly.coding.me/2016/11/23/install_ns2/</url>
      <content type="html"><![CDATA[<h3 id="下载ns-allinone-2-35"><a href="#下载ns-allinone-2-35" class="headerlink" title="下载ns-allinone-2.35"></a>下载ns-allinone-2.35</h3><p>1.去<a href="http://www.isi.edu/nsnam/ns/" target="_blank" rel="noopener">官网</a>下载安装包<br><img src="http://oh2r5yxfc.bkt.clouddn.com/ns2_download1.png" alt="第一步"><br><img src="http://oh2r5yxfc.bkt.clouddn.com/ns2_download2.png" alt="第二步"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>解压下载的文件并进入到加压后的目录<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar zvxf ns-allinone-2.35.tar.gz <span class="string">/opt/</span></span><br><span class="line"><span class="keyword">cd</span> <span class="string">/opt/ns-allinone-2.35</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.安装依赖<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> update</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> upgrade</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install build-essential autoconf automake</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install perl xgraph libxt-dev libx11-dev libxmu-dev</span><br></pre></td></tr></table></figure></p>
<ol>
<li>修改 ns-allinone-2.35/ns-2.35/linkstate 中 ls.h 文件的代码 ,<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void eraseAll() &#123; erase(baseMap::<span class="keyword">begin</span>(), baseMap::<span class="keyword">end</span>()); &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>改为：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> eraseAll() &#123; <span class="keyword">this</span>-&gt;erase(baseMap::<span class="built_in">begin</span>(), baseMap::<span class="built_in">end</span>()); &#125;</span><br></pre></td></tr></table></figure></p>
<p>4.开始安装，可能需要十几分钟<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./<span class="keyword">install</span></span><br></pre></td></tr></table></figure></p>
<p>当出现下面提示就表示安装成功了<br><img src="http://oh2r5yxfc.bkt.clouddn.com/ns2_download3.png" alt="安装成功"><br>5.配置环境变量<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim ~<span class="string">/.bashrc</span></span><br></pre></td></tr></table></figure></p>
<p>在最后添加<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PATH=<span class="variable">$PATH</span><span class="symbol">:/opt/ns-allinone-</span><span class="number">2.35</span>/<span class="symbol">bin:</span>/opt/ns-allinone-<span class="number">2.35</span>/tcl8.<span class="number">5.10</span>/<span class="symbol">unix:</span>/opt/ns-allinone-<span class="number">2.35</span>/tk8.<span class="number">5.10</span>/unix</span><br><span class="line">export LD_LIBRARY_PATH=<span class="regexp">/opt/ns</span>-allinone-<span class="number">2.35</span>/otcl-<span class="number">1.14</span><span class="symbol">:/opt/ns-allinone-</span><span class="number">2.35</span>/lib</span><br><span class="line">export TCL_LIBRARY=<span class="regexp">/opt/ns</span>-allinone-<span class="number">2.35</span>/tcl8.<span class="number">5.10</span>/library</span><br></pre></td></tr></table></figure></p>
<p>使环境变量生效<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<p>6.验证<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~<span class="variable">$ </span>ns</span><br><span class="line">~<span class="variable">$ </span>%</span><br></pre></td></tr></table></figure></p>
<p>如果出现%就表示安装成功了<br>７．安装nam<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ns-allinone-<span class="number">2.35</span>/nam-<span class="number">1.15</span></span><br><span class="line">./configure</span><br><span class="line">sudo <span class="keyword">make</span></span><br><span class="line"><span class="keyword">make</span> install</span><br></pre></td></tr></table></figure></p>
<p>测试<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nam</span></span><br></pre></td></tr></table></figure></p>
<p>如果弹出nam console说明nam安装成功<br>8.测试simple.tcl<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cp</span> /<span class="keyword">opt</span>/ns-allinone-<span class="number">2.35</span>/ns-<span class="number">2.35</span>/<span class="keyword">tcl</span>/<span class="keyword">ex</span>/simple.<span class="keyword">tcl</span> ~</span><br><span class="line"><span class="keyword">cd</span> ~</span><br><span class="line">ns simple.<span class="keyword">tcl</span></span><br></pre></td></tr></table></figure></p>
<p>如果出现下面的界面，那么就全部安装成功！<br><img src="http://oh2r5yxfc.bkt.clouddn.com/ns2_download4.png" alt="全部安装成功"></p>
]]></content>
      
        <categories>
            
            <category> ubuntu学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Chrome浏览器host配置]]></title>
      <url>http://Racaly.coding.me/2016/10/13/host/</url>
      <content type="html"><![CDATA[<h3 id="Chrome浏览器host配置"><a href="#Chrome浏览器host配置" class="headerlink" title="Chrome浏览器host配置"></a>Chrome浏览器host配置</h3><p>1、host文件配置</p>
<h4 id="Windows平台"><a href="#Windows平台" class="headerlink" title="Windows平台"></a>Windows平台</h4><p>1.使用文本编辑器打开： %SystemRoot%\System32\drivers\etc\hosts<br>2.将 <a href="https://raw.githubusercontent.com/racaljk/hosts/master/hosts" target="_blank" rel="noopener">hosts</a> 全部内容复制到上面的文件内并保存</p>
<h5 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h5><p>1.将 hosts 全部内容复制到/etc/hosts中并保存<br>2.或者在终端执行：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/racaljk/</span>hosts<span class="regexp">/master/</span>hosts -qO <span class="regexp">/tmp/</span>hosts &amp;&amp; sudo sh -c <span class="string">'cat /tmp/hosts &gt; /etc/hosts'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="二、Chrome配置"><a href="#二、Chrome配置" class="headerlink" title="二、Chrome配置"></a>二、Chrome配置</h3><p>1.地址栏输入：<code>chrome://net-internals/#hsts</code>,回车<br>2.<code>Input a domain name to add it to the HSTS set:</code>这一行下面的<code>Domain: [ ]</code>输入<code>www.google.com.hk</code>点 <strong>Add</strong>按钮</p>
<h3 id="三、重启浏览器"><a href="#三、重启浏览器" class="headerlink" title="三、重启浏览器"></a>三、重启浏览器</h3><p><a href="https://github.com/racaljk/hosts" target="_blank" rel="noopener">原文</a>及相关问题 请访问<code>https://github.com/racaljk/hosts</code><br><strong>已经失效</strong></p>
]]></content>
      
        <categories>
            
            <category> ubuntu学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git忽略]]></title>
      <url>http://Racaly.coding.me/2016/09/04/gitignore/</url>
      <content type="html"><![CDATA[<h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p> 1.在项目的根目录下打开.gitignore文件（如果没有则新建），添加你要忽略的文件或者文件夹，例如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json`</span><br></pre></td></tr></table></figure></p>
<p> 2.清除缓存<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm -rf --cached .</span><br><span class="line">git <span class="keyword">add</span><span class="bash"> .</span></span><br></pre></td></tr></table></figure></p>
<p>3.这时修改的.gitignore就生效了。</p>
]]></content>
      
        <categories>
            
            <category> git学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Javascript闭包]]></title>
      <url>http://Racaly.coding.me/2016/08/26/%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<h3 id="Javascript闭包"><a href="#Javascript闭包" class="headerlink" title="Javascript闭包"></a>Javascript闭包</h3><p>闭包是指能够访问自由变量的函数 (变量在本地使用，但在闭包中定义)。换句话说，定义在闭包中的函数可以“记忆”它被创建时候的环境。<br><strong>先看下面这个函数</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> city = <span class="string">"西安"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getCity</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(city);</span><br><span class="line">  &#125;</span><br><span class="line">  getCity();</span><br><span class="line">&#125;</span><br><span class="line">foo();<span class="comment">//控制台输出'西安'</span></span><br></pre></td></tr></table></figure></p>
<p>函数 foo() 创建了一个局部变量 city，然后定义了名为 getCity() 的函数。 getCity() 是一个内部函数——定义于 foo() 之内且仅在该函数体内可用。getCity() 没有任何自己的局部变量，然而它可以访问到外部函数的变量，即可以使用父函数中声明的 city 变量。</p>
<h4 id="一、闭包"><a href="#一、闭包" class="headerlink" title="一、闭包"></a>一、闭包</h4><p><strong>再看这样一个函数</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> city = <span class="string">"西安"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getCity</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(city);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getCity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo2 = foo1();</span><br><span class="line">foo2();<span class="comment">//控制台输出西安</span></span><br></pre></td></tr></table></figure></p>
<p>运行这段代码的效果和之前的 foo() 示例完全一样：字符串 “西安” 将被显示在一个 控制台中。其中的不同也是有意思的地方在于 getCity()内部函数在执行前被从其外围函数foo1中返回了。<br>这段代码看起来别扭却能正常运行。通常，函数中的局部变量仅在函数的执行期间可用。一旦foo1()执行过后，我们会很合理的认为 city变量将不再可用。虽然代码运行的没问题，但实际并不是这样的。<br>这个谜题的答案是foo1变成一个闭包了。闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，foo1是一个闭包，由getCity函数和闭包创建时存在的”西安”字符串形成。<br>下面是一个更有意思的示例 — makeAdder 函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">2</span>));  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">2</span>)); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></p>
<p>在这个示例中，我们定义了 makeAdder(x) 函数：带有一个参数 x 并返回一个新的函数。返回的函数带有一个参数 y，并返回 x 和 y 的和。<br>从本质上讲，makeAdder 是一个函数工厂 — 创建将指定的值和它的参数求和的函数，在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。<br>add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。</p>
<p>实用的闭包<br>理论就是这些了 — 可是闭包确实有用吗？让我们看看闭包的实践意义。闭包允许将函数与其所操作的某些数据（环境）关连起来。这显然类似于面向对象编程。在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。</p>
<p>因而，一般说来，可以使用只有一个方法的对象的地方，都可以使用闭包。</p>
<p>在 Web 中，您可能想这样做的情形非常普遍。大部分我们所写的 Web JavaScript 代码都是事件驱动的 — 定义某种行为，然后将其添加到用户触发的事件之上（比如点击或者按键）。我们的代码通常添加为回调：响应事件而执行的函数。</p>
<p>以下是一个实际的示例：<br>假设我们想在页面上添加一些可以调整字号的按钮。一种方法是以像素为单位指定 body 元素的 font-size，然后通过相对的 em 单位设置页面中其它元素（例如页眉）的字号：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Helvetica, Arial, sans-serif;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们的交互式的文本尺寸按钮可以修改 body 元素的 font-size 属性，而由于我们使用相对的单位，页面中的其它元素也会相应地调整。<br>以下是 JavaScript：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeSizer</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.style.fontSize = size + <span class="string">'px'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> size12 = makeSizer(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> size14 = makeSizer(<span class="number">14</span>);</span><br><span class="line"><span class="keyword">var</span> size16 = makeSizer(<span class="number">16</span>);</span><br></pre></td></tr></table></figure></p>
<p>size12，size14 和 size16 为将 body 文本相应地调整为 12，14，16 像素的函数。我们可以将它们分别添加到按钮上（这里是链接）。如下所示：</p>
<p>document.getElementById(‘size-12’).onclick = size12;<br>document.getElementById(‘size-14’).onclick = size14;<br>document.getElementById(‘size-16’).onclick = size16;<br><a href="#" id="size-12">12</a><br><a href="#" id="size-14">14</a><br><a href="#" id="size-16">16</a></p>
<p>用闭包模拟私有方法<br>诸如 Java 在内的一些语言支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。</p>
<p>对此，JavaScript 并不提供原生的支持，但是可以使用闭包模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。</p>
<p>下面的示例展现了如何使用闭包来定义公共函数，且其可以访问私有函数和变量。这个方式也称为 模块模式（module pattern）：</p>
<p>var Counter = (function() {<br>  var privateCounter = 0;<br>  function changeBy(val) {<br>    privateCounter += val;<br>  }<br>  return {<br>    increment: function() {<br>      changeBy(1);<br>    },<br>    decrement: function() {<br>      changeBy(-1);<br>    },<br>    value: function() {<br>      return privateCounter;<br>    }<br>  }<br>})();</p>
<p>console.log(Counter.value()); /<em> logs 0 </em>/<br>Counter.increment();<br>Counter.increment();<br>console.log(Counter.value()); /<em> logs 2 </em>/<br>Counter.decrement();<br>console.log(Counter.value()); /<em> logs 1 </em>/<br>这里有很多细节。在以往的示例中，每个闭包都有它自己的环境；而这次我们只创建了一个环境，为三个函数所共享：Counter.increment，Counter.decrement 和 Counter.value。</p>
<p>该共享环境创建于一个匿名函数体内，该函数一经定义立刻执行。环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。 这两项都无法在匿名函数外部直接访问。必须通过匿名包装器返回的三个公共函数访问。</p>
<p>这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法范围的作用域，它们都可以访问 privateCounter 变量和 changeBy 函数。</p>
<p>您应该注意到了，我们定义了一个匿名函数用于创建计数器，然后直接调用该函数，并将返回值赋给 Counter 变量。也可以将这个函数保存到另一个变量中，以便创建多个计数器。</p>
<p>var makeCounter = function() {<br>  var privateCounter = 0;<br>  function changeBy(val) {<br>    privateCounter += val;<br>  }<br>  return {<br>    increment: function() {<br>      changeBy(1);<br>    },<br>    decrement: function() {<br>      changeBy(-1);<br>    },<br>    value: function() {<br>      return privateCounter;<br>    }<br>  }<br>};</p>
<p>var Counter1 = makeCounter();<br>var Counter2 = makeCounter();<br>console.log(Counter1.value()); /<em> logs 0 </em>/<br>Counter1.increment();<br>Counter1.increment();<br>console.log(Counter1.value()); /<em> logs 2 </em>/<br>Counter1.decrement();<br>console.log(Counter1.value()); /<em> logs 1 </em>/<br>console.log(Counter2.value()); /<em> logs 0 </em>/<br>请注意两个计数器是如何维护它们各自的独立性的。每次调用 makeCounter() 函数期间，其环境是不同的。每次调用中， privateCounter 中含有不同的实例。</p>
<p>这种形式的闭包提供了许多通常由面向对象编程U所享有的益处，尤其是数据隐藏和封装。</p>
<p>在循环中创建闭包：一个常见错误<br>在 JavaScript 1.7 引入 let 关键字 之前，闭包的一个常见的问题发生于在循环中创建闭包。参考下面的示例：</p>
<p></p><p id="help">Helpful notes will appear here</p><p></p>
<p></p><p>E-mail: <input type="text" id="email" name="email"></p><p></p>
<p></p><p>Name: <input type="text" id="name" name="name"></p><p></p>
<p></p><p>Age: <input type="text" id="age" name="age"></p><br>function showHelp(help) {<br>  document.getElementById(‘help’).innerHTML = help;<br>}<p></p>
<p>function setupHelp() {<br>  var helpText = [<br>      {‘id’: ‘email’, ‘help’: ‘Your e-mail address’},<br>      {‘id’: ‘name’, ‘help’: ‘Your full name’},<br>      {‘id’: ‘age’, ‘help’: ‘Your age (you must be over 16)’}<br>    ];</p>
<p>  for (var i = 0; i &lt; helpText.length; i++) {<br>    var item = helpText[i];<br>    document.getElementById(item.id).onfocus = function() {<br>      showHelp(item.help);<br>    }<br>  }<br>}</p>
<p>setupHelp();</p>
<p>数组 helpText 中定义了三个有用的提示信息，每一个都关联于对应的文档中的输入域的 ID。通过循环这三项定义，依次为每一个输入域添加了一个 onfocus 事件处理函数，以便显示帮助信息。</p>
<p>运行这段代码后，您会发现它没有达到想要的效果。无论焦点在哪个输入域上，显示的都是关于年龄的消息。</p>
<p>该问题的原因在于赋给 onfocus 是闭包（setupHelp）中的匿名函数而不是闭包对象；在闭包（setupHelp）中一共创建了三个匿名函数，但是它们都共享同一个环境（item）。在 onfocus 的回调被执行时，循环早已经完成，且此时 item 变量（由所有三个闭包所共享）已经指向了 helpText 列表中的最后一项。</p>
<p>解决这个问题的一种方案是使onfocus指向一个新的闭包对象。</p>
<p>function showHelp(help) {<br>  document.getElementById(‘help’).innerHTML = help;<br>}</p>
<p>function makeHelpCallback(help) {<br>  return function() {<br>    showHelp(help);<br>  };<br>}</p>
<p>function setupHelp() {<br>  var helpText = [<br>      {‘id’: ‘email’, ‘help’: ‘Your e-mail address’},<br>      {‘id’: ‘name’, ‘help’: ‘Your full name’},<br>      {‘id’: ‘age’, ‘help’: ‘Your age (you must be over 16)’}<br>    ];</p>
<p>  for (var i = 0; i &lt; helpText.length; i++) {<br>    var item = helpText[i];<br>    document.getElementById(item.id).onfocus = makeHelpCallback(item.help);<br>  }<br>}</p>
<p>setupHelp();</p>
<p>这段代码可以如我们所期望的那样工作。所有的回调不再共享同一个环境， makeHelpCallback 函数为每一个回调创建一个新的环境。在这些环境中，help 指向 helpText 数组中对应的字符串。</p>
<p>性能考量<br>如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。</p>
<p>例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用，方法都会被重新赋值一次（也就是说，为每一个对象的创建）。</p>
<p>考虑以下虽然不切实际但却说明问题的示例：</p>
<p>function MyObject(name, message) {<br>  this.name = name.toString();<br>  this.message = message.toString();<br>  this.getName = function() {<br>    return this.name;<br>  };</p>
<p>  this.getMessage = function() {<br>    return this.message;<br>  };<br>}<br>上面的代码并未利用到闭包的益处，因此，应该修改为如下常规形式：</p>
<p>function MyObject(name, message) {<br>  this.name = name.toString();<br>  this.message = message.toString();<br>}<br>MyObject.prototype = {<br>  getName: function() {<br>    return this.name;<br>  },<br>  getMessage: function() {<br>    return this.message;<br>  }<br>};<br>或者改成：</p>
<p>function MyObject(name, message) {<br>  this.name = name.toString();<br>  this.message = message.toString();<br>}<br>MyObject.prototype.getName = function() {<br>  return this.name;<br>};<br>MyObject.prototype.getMessage = function() {<br>  return this.message;<br>};<br>在前面的两个示例中，继承的原型可以为所有对象共享，且不必在每一次创建对象时定义方法。参见 对象模型的细节 一章可以了解更为详细的信息。</p>
]]></content>
      
        <categories>
            
            <category> js学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[制作一个进入项目目录的小脚本]]></title>
      <url>http://Racaly.coding.me/2016/07/13/into-project-shell/</url>
      <content type="html"><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在我的项目文件夹里有四个不同的项目，/app/project/,项目文件夹分别为testa，testb，testc，testd。每次启动ubuntu后我要进入第一个项目就需要运行cd app/project/testa,git statua 。所以需要一个自定义的命令可以是我直接进入指定的项目目录，并执行一次git status。因为我是希望根据我传的参数进入指定的目录，会需要一些判断。所以单纯使用alias有点不太妥当，这里就使用alias 和shell 脚本来实现这个功能。</p>
<h3 id="写一个简单的shell脚本"><a href="#写一个简单的shell脚本" class="headerlink" title="写一个简单的shell脚本"></a>写一个简单的shell脚本</h3><p>1.新建一个into_project.sh文件：<br>    <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!<span class="regexp">/bin/</span>bash</span><br><span class="line">#声明一个关联数组并赋值</span><br><span class="line">declare -A <span class="keyword">project</span></span><br><span class="line"><span class="keyword">project</span>[a]=~<span class="regexp">/app/</span><span class="keyword">project</span><span class="regexp">/testa/</span></span><br><span class="line"><span class="keyword">project</span>[b]=~<span class="regexp">/app/</span><span class="keyword">project</span><span class="regexp">/testb/</span></span><br><span class="line"><span class="keyword">project</span>[c]=~<span class="regexp">/app/</span><span class="keyword">project</span><span class="regexp">/testc/</span></span><br><span class="line"><span class="keyword">project</span>[d]=~<span class="regexp">/app/</span><span class="keyword">project</span><span class="regexp">/testd/</span></span><br></pre></td></tr></table></figure></p>
<p>至于什么叫关联数组或者关联数组如何定义，请自行google搜索shell脚本的关联数组，在这里使用关联数组是因为需要下标可以是字符串的数组。然后给数组赋值</p>
<p>2.完整代码，实现功能</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/</span></span><br><span class="line"><span class="comment">#项目目录</span></span><br><span class="line"><span class="built_in">declare</span> -A project</span><br><span class="line">project[a]=~/app/project/testa/</span><br><span class="line">project[b]=~/app/project/testb/</span><br><span class="line">project[c]=~/app/project/testc/</span><br><span class="line">project[d]=~/app/project/testd/</span><br><span class="line">falg=<span class="literal">false</span>     <span class="comment">#flag默认为false</span></span><br><span class="line"><span class="keyword">if</span> [ x<span class="variable">$1</span> != x ]; <span class="keyword">then</span>      <span class="comment">#$1为传进来的参数，这里判断它是否为空</span></span><br><span class="line">	<span class="keyword">for</span> key <span class="keyword">in</span> <span class="variable">$&#123;(k)project&#125;</span>; <span class="keyword">do</span>     <span class="comment">#循环这个关联数组的key</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span>x = <span class="string">"<span class="variable">$key</span>"</span>x ]; <span class="keyword">then</span>   <span class="comment">#判断传进来的参数是否和里边的其中一个相等</span></span><br><span class="line">			falg=<span class="literal">true</span>   <span class="comment">#如果相等，flag为true</span></span><br><span class="line">			<span class="built_in">break</span>   <span class="comment">#结束循环</span></span><br><span class="line">		<span class="keyword">fi</span></span><br><span class="line">	<span class="keyword">done</span></span><br><span class="line">	<span class="keyword">if</span> <span class="variable">$falg</span>; <span class="keyword">then</span>     <span class="comment">#如果falg为true 执行这里边的内容</span></span><br><span class="line">		<span class="built_in">echo</span> <span class="string">"您已进入<span class="variable">$project</span>[<span class="variable">$1</span>]项目"</span></span><br><span class="line">		<span class="built_in">cd</span> <span class="variable">$project</span>[<span class="variable">$1</span>]      <span class="comment">#进入刚才找到的那个目录</span></span><br><span class="line">  	git status      <span class="comment">#运行git status</span></span><br><span class="line">  <span class="keyword">else</span>    <span class="comment">#否则，根据传进来的参数没找到对应的项目</span></span><br><span class="line">  	<span class="built_in">echo</span> <span class="string">"没有这个项目，项目列表："</span></span><br><span class="line">  	<span class="keyword">for</span> key <span class="keyword">in</span> <span class="variable">$&#123;(k)project&#125;</span>; <span class="keyword">do</span> <span class="built_in">printf</span> <span class="string">"名称:%-5s %-6s\n"</span> <span class="variable">$key</span> <span class="variable">$project</span>[<span class="variable">$key</span>]; <span class="keyword">done</span>    <span class="comment">#遍历project数组并输出，以提示</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span>  <span class="comment">#如果$1为空，没有传参数</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"请指定一个项目！项目列表："</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> <span class="variable">$&#123;(k)project&#125;</span>; <span class="keyword">do</span> <span class="built_in">printf</span> <span class="string">"名称:%-5s %-6s\n"</span> <span class="variable">$key</span> <span class="variable">$project</span>[<span class="variable">$key</span>]; <span class="keyword">done</span>     <span class="comment">#遍历project数组并输出，以提示</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h3 id="定义自定义命令"><a href="#定义自定义命令" class="headerlink" title="定义自定义命令"></a>定义自定义命令</h3><p>1.测试<br>&emsp;&emsp;现在需要一个命令来调用这个脚本，当然，可以先测试一下。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">username$</span><span class="bash"> /bin/bash into_project.sh a</span></span><br></pre></td></tr></table></figure></p>
<p>输出如下：<br><strong>username$<br>    您已进入/home/username/project/testa/项目<br>    位于分支 master<br>    您的分支与上游分支 ‘origin/master’ 一致。<br>    无文件要提交，干净的工作区<br>    username$</strong></p>
<p>可以发现，脚本运行成功了，但是当前shell并没有进入指定的文夹里，因为运行into_project.sh时，会新启一个shell脚本，执行完毕后关闭，所以需要这么执行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">username$</span><span class="bash"> <span class="built_in">source</span> into_project.sh a</span></span><br></pre></td></tr></table></figure></p>
<p>输出如下：<br><strong>username$<br>    您已进入/home/username/project/testa/项目<br>    位于分支 master<br>    您的分支与上游分支 ‘origin/master’ 一致。<br>    无文件要提交，干净的工作区<br>    username:~/project/testa/$</strong><br>2.定义命令<br>ubuntu可以使用alias来将现有的命令自定义，相当于起了一个别名如alias cl = “cd project/texta”。 alias 根本就不支持传递命令行参数。不过，我们可以变通的解决这个问题，即定义函数。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">into</span>='<span class="keyword">into</span>() &#123; source /home/zy/into_project.sh ;&#125;; <span class="keyword">into</span>'</span><br></pre></td></tr></table></figure>
<p>但是这个命令在用户关闭shell进程后就失效了。我用的是oh-my-zsh，所以打开**~/.zshrc文件，将刚才的命令添加进去，重启或者source ~/.zshrc,这样这个命令就可以使用了</p>
]]></content>
      
        <categories>
            
            <category> ubuntu学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
